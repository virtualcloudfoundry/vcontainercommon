// Code generated by protoc-gen-gogo.
// source: garden.proto
// DO NOT EDIT!

package vcontainermodels

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf2 "github.com/gogo/protobuf/types"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Capacity struct {
	MemoryInBytes uint64 `protobuf:"varint,1,opt,name=MemoryInBytes,proto3" json:"MemoryInBytes,omitempty"`
	DiskInBytes   uint64 `protobuf:"varint,2,opt,name=DiskInBytes,proto3" json:"DiskInBytes,omitempty"`
	MaxContainers uint64 `protobuf:"varint,3,opt,name=MaxContainers,proto3" json:"MaxContainers,omitempty"`
}

func (m *Capacity) Reset()                    { *m = Capacity{} }
func (*Capacity) ProtoMessage()               {}
func (*Capacity) Descriptor() ([]byte, []int) { return fileDescriptorGarden, []int{0} }

func (m *Capacity) GetMemoryInBytes() uint64 {
	if m != nil {
		return m.MemoryInBytes
	}
	return 0
}

func (m *Capacity) GetDiskInBytes() uint64 {
	if m != nil {
		return m.DiskInBytes
	}
	return 0
}

func (m *Capacity) GetMaxContainers() uint64 {
	if m != nil {
		return m.MaxContainers
	}
	return 0
}

type ContainerSpec struct {
	Handle    string                     `protobuf:"bytes,1,opt,name=Handle,proto3" json:"Handle,omitempty"`
	GraceTime *google_protobuf2.Duration `protobuf:"bytes,2,opt,name=GraceTime" json:"GraceTime,omitempty"`
	// Deprecated in favour of Image property
	RootFSPath string      `protobuf:"bytes,3,opt,name=RootFSPath,proto3" json:"RootFSPath,omitempty"`
	Image      ImageRef    `protobuf:"bytes,4,opt,name=Image" json:"Image"`
	BindMounts []BindMount `protobuf:"bytes,5,rep,name=BindMounts" json:"BindMounts"`
	Network    string      `protobuf:"bytes,6,opt,name=Network,proto3" json:"Network,omitempty"`
	// Properties is a sequence of string key/value pairs providing arbitrary
	// data about the container. The keys are assumed to be unique but this is not
	// enforced via the protocol.
	Properties *Properties `protobuf:"bytes,7,opt,name=Properties" json:"Properties,omitempty"`
	// TODO
	Env []string `protobuf:"bytes,8,rep,name=Env" json:"Env,omitempty"`
	// If Privileged is true the container does not have a user namespace and the root user in the container
	// is the same as the root user in the host. Otherwise, the container has a user namespace and the root
	// user in the container is mapped to a non-root user in the host. Defaults to false.
	Privileged bool `protobuf:"varint,9,opt,name=Privileged,proto3" json:"Privileged,omitempty"`
	// Limits to be applied to the newly created container.
	Limits Limits              `protobuf:"bytes,10,opt,name=Limits" json:"Limits"`
	NetIn  []NetInRequest      `protobuf:"bytes,11,rep,name=NetIn" json:"NetIn"`
	NetOut []NetOutRuleRequest `protobuf:"bytes,12,rep,name=NetOut" json:"NetOut"`
}

func (m *ContainerSpec) Reset()                    { *m = ContainerSpec{} }
func (*ContainerSpec) ProtoMessage()               {}
func (*ContainerSpec) Descriptor() ([]byte, []int) { return fileDescriptorGarden, []int{1} }

func (m *ContainerSpec) GetHandle() string {
	if m != nil {
		return m.Handle
	}
	return ""
}

func (m *ContainerSpec) GetGraceTime() *google_protobuf2.Duration {
	if m != nil {
		return m.GraceTime
	}
	return nil
}

func (m *ContainerSpec) GetRootFSPath() string {
	if m != nil {
		return m.RootFSPath
	}
	return ""
}

func (m *ContainerSpec) GetImage() ImageRef {
	if m != nil {
		return m.Image
	}
	return ImageRef{}
}

func (m *ContainerSpec) GetBindMounts() []BindMount {
	if m != nil {
		return m.BindMounts
	}
	return nil
}

func (m *ContainerSpec) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *ContainerSpec) GetProperties() *Properties {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *ContainerSpec) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *ContainerSpec) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *ContainerSpec) GetLimits() Limits {
	if m != nil {
		return m.Limits
	}
	return Limits{}
}

func (m *ContainerSpec) GetNetIn() []NetInRequest {
	if m != nil {
		return m.NetIn
	}
	return nil
}

func (m *ContainerSpec) GetNetOut() []NetOutRuleRequest {
	if m != nil {
		return m.NetOut
	}
	return nil
}

type Limits struct {
	Bandwidth BandwidthLimits `protobuf:"bytes,1,opt,name=Bandwidth" json:"Bandwidth"`
	CPU       CPULimits       `protobuf:"bytes,2,opt,name=CPU" json:"CPU"`
	Disk      DiskLimits      `protobuf:"bytes,3,opt,name=Disk" json:"Disk"`
	Memory    MemoryLimits    `protobuf:"bytes,4,opt,name=Memory" json:"Memory"`
	Pid       PidLimits       `protobuf:"bytes,5,opt,name=Pid" json:"Pid"`
}

func (m *Limits) Reset()                    { *m = Limits{} }
func (*Limits) ProtoMessage()               {}
func (*Limits) Descriptor() ([]byte, []int) { return fileDescriptorGarden, []int{2} }

func (m *Limits) GetBandwidth() BandwidthLimits {
	if m != nil {
		return m.Bandwidth
	}
	return BandwidthLimits{}
}

func (m *Limits) GetCPU() CPULimits {
	if m != nil {
		return m.CPU
	}
	return CPULimits{}
}

func (m *Limits) GetDisk() DiskLimits {
	if m != nil {
		return m.Disk
	}
	return DiskLimits{}
}

func (m *Limits) GetMemory() MemoryLimits {
	if m != nil {
		return m.Memory
	}
	return MemoryLimits{}
}

func (m *Limits) GetPid() PidLimits {
	if m != nil {
		return m.Pid
	}
	return PidLimits{}
}

type ContainerInfoEntry struct {
	Info ContainerInfo `protobuf:"bytes,1,opt,name=Info" json:"Info"`
	Err  *Error        `protobuf:"bytes,2,opt,name=Err" json:"Err,omitempty"`
}

func (m *ContainerInfoEntry) Reset()                    { *m = ContainerInfoEntry{} }
func (*ContainerInfoEntry) ProtoMessage()               {}
func (*ContainerInfoEntry) Descriptor() ([]byte, []int) { return fileDescriptorGarden, []int{3} }

func (m *ContainerInfoEntry) GetInfo() ContainerInfo {
	if m != nil {
		return m.Info
	}
	return ContainerInfo{}
}

func (m *ContainerInfoEntry) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

// the client service messages
type BulkInfoRequest struct {
	Handles []string `protobuf:"bytes,1,rep,name=Handles" json:"Handles,omitempty"`
}

func (m *BulkInfoRequest) Reset()                    { *m = BulkInfoRequest{} }
func (*BulkInfoRequest) ProtoMessage()               {}
func (*BulkInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorGarden, []int{4} }

func (m *BulkInfoRequest) GetHandles() []string {
	if m != nil {
		return m.Handles
	}
	return nil
}

type BulkInfoResponse struct {
	ContainerInfoEntry map[string]*ContainerInfoEntry `protobuf:"bytes,1,rep,name=ContainerInfoEntry" json:"ContainerInfoEntry,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BulkInfoResponse) Reset()                    { *m = BulkInfoResponse{} }
func (*BulkInfoResponse) ProtoMessage()               {}
func (*BulkInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorGarden, []int{5} }

func (m *BulkInfoResponse) GetContainerInfoEntry() map[string]*ContainerInfoEntry {
	if m != nil {
		return m.ContainerInfoEntry
	}
	return nil
}

type ContainerMetricsEntry struct {
	Metrics Metrics `protobuf:"bytes,1,opt,name=Metrics" json:"Metrics"`
	Err     *Error  `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
}

func (m *ContainerMetricsEntry) Reset()                    { *m = ContainerMetricsEntry{} }
func (*ContainerMetricsEntry) ProtoMessage()               {}
func (*ContainerMetricsEntry) Descriptor() ([]byte, []int) { return fileDescriptorGarden, []int{6} }

func (m *ContainerMetricsEntry) GetMetrics() Metrics {
	if m != nil {
		return m.Metrics
	}
	return Metrics{}
}

func (m *ContainerMetricsEntry) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

type BulkMetricsRequest struct {
	Handles []string `protobuf:"bytes,1,rep,name=Handles" json:"Handles,omitempty"`
}

func (m *BulkMetricsRequest) Reset()                    { *m = BulkMetricsRequest{} }
func (*BulkMetricsRequest) ProtoMessage()               {}
func (*BulkMetricsRequest) Descriptor() ([]byte, []int) { return fileDescriptorGarden, []int{7} }

func (m *BulkMetricsRequest) GetHandles() []string {
	if m != nil {
		return m.Handles
	}
	return nil
}

type BulkMetricsResponse struct {
	ContainerMetricsEntry map[string]*ContainerMetricsEntry `protobuf:"bytes,1,rep,name=ContainerMetricsEntry" json:"ContainerMetricsEntry,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BulkMetricsResponse) Reset()                    { *m = BulkMetricsResponse{} }
func (*BulkMetricsResponse) ProtoMessage()               {}
func (*BulkMetricsResponse) Descriptor() ([]byte, []int) { return fileDescriptorGarden, []int{8} }

func (m *BulkMetricsResponse) GetContainerMetricsEntry() map[string]*ContainerMetricsEntry {
	if m != nil {
		return m.ContainerMetricsEntry
	}
	return nil
}

func init() {
	proto.RegisterType((*Capacity)(nil), "vcontainermodels.Capacity")
	proto.RegisterType((*ContainerSpec)(nil), "vcontainermodels.ContainerSpec")
	proto.RegisterType((*Limits)(nil), "vcontainermodels.Limits")
	proto.RegisterType((*ContainerInfoEntry)(nil), "vcontainermodels.ContainerInfoEntry")
	proto.RegisterType((*BulkInfoRequest)(nil), "vcontainermodels.BulkInfoRequest")
	proto.RegisterType((*BulkInfoResponse)(nil), "vcontainermodels.BulkInfoResponse")
	proto.RegisterType((*ContainerMetricsEntry)(nil), "vcontainermodels.ContainerMetricsEntry")
	proto.RegisterType((*BulkMetricsRequest)(nil), "vcontainermodels.BulkMetricsRequest")
	proto.RegisterType((*BulkMetricsResponse)(nil), "vcontainermodels.BulkMetricsResponse")
}
func (this *Capacity) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Capacity)
	if !ok {
		that2, ok := that.(Capacity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.MemoryInBytes != that1.MemoryInBytes {
		return false
	}
	if this.DiskInBytes != that1.DiskInBytes {
		return false
	}
	if this.MaxContainers != that1.MaxContainers {
		return false
	}
	return true
}
func (this *ContainerSpec) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerSpec)
	if !ok {
		that2, ok := that.(ContainerSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Handle != that1.Handle {
		return false
	}
	if !this.GraceTime.Equal(that1.GraceTime) {
		return false
	}
	if this.RootFSPath != that1.RootFSPath {
		return false
	}
	if !this.Image.Equal(&that1.Image) {
		return false
	}
	if len(this.BindMounts) != len(that1.BindMounts) {
		return false
	}
	for i := range this.BindMounts {
		if !this.BindMounts[i].Equal(&that1.BindMounts[i]) {
			return false
		}
	}
	if this.Network != that1.Network {
		return false
	}
	if !this.Properties.Equal(that1.Properties) {
		return false
	}
	if len(this.Env) != len(that1.Env) {
		return false
	}
	for i := range this.Env {
		if this.Env[i] != that1.Env[i] {
			return false
		}
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if !this.Limits.Equal(&that1.Limits) {
		return false
	}
	if len(this.NetIn) != len(that1.NetIn) {
		return false
	}
	for i := range this.NetIn {
		if !this.NetIn[i].Equal(&that1.NetIn[i]) {
			return false
		}
	}
	if len(this.NetOut) != len(that1.NetOut) {
		return false
	}
	for i := range this.NetOut {
		if !this.NetOut[i].Equal(&that1.NetOut[i]) {
			return false
		}
	}
	return true
}
func (this *Limits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Limits)
	if !ok {
		that2, ok := that.(Limits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Bandwidth.Equal(&that1.Bandwidth) {
		return false
	}
	if !this.CPU.Equal(&that1.CPU) {
		return false
	}
	if !this.Disk.Equal(&that1.Disk) {
		return false
	}
	if !this.Memory.Equal(&that1.Memory) {
		return false
	}
	if !this.Pid.Equal(&that1.Pid) {
		return false
	}
	return true
}
func (this *ContainerInfoEntry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerInfoEntry)
	if !ok {
		that2, ok := that.(ContainerInfoEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(&that1.Info) {
		return false
	}
	if !this.Err.Equal(that1.Err) {
		return false
	}
	return true
}
func (this *BulkInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BulkInfoRequest)
	if !ok {
		that2, ok := that.(BulkInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Handles) != len(that1.Handles) {
		return false
	}
	for i := range this.Handles {
		if this.Handles[i] != that1.Handles[i] {
			return false
		}
	}
	return true
}
func (this *BulkInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BulkInfoResponse)
	if !ok {
		that2, ok := that.(BulkInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.ContainerInfoEntry) != len(that1.ContainerInfoEntry) {
		return false
	}
	for i := range this.ContainerInfoEntry {
		if !this.ContainerInfoEntry[i].Equal(that1.ContainerInfoEntry[i]) {
			return false
		}
	}
	return true
}
func (this *ContainerMetricsEntry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerMetricsEntry)
	if !ok {
		that2, ok := that.(ContainerMetricsEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Metrics.Equal(&that1.Metrics) {
		return false
	}
	if !this.Err.Equal(that1.Err) {
		return false
	}
	return true
}
func (this *BulkMetricsRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BulkMetricsRequest)
	if !ok {
		that2, ok := that.(BulkMetricsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Handles) != len(that1.Handles) {
		return false
	}
	for i := range this.Handles {
		if this.Handles[i] != that1.Handles[i] {
			return false
		}
	}
	return true
}
func (this *BulkMetricsResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BulkMetricsResponse)
	if !ok {
		that2, ok := that.(BulkMetricsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.ContainerMetricsEntry) != len(that1.ContainerMetricsEntry) {
		return false
	}
	for i := range this.ContainerMetricsEntry {
		if !this.ContainerMetricsEntry[i].Equal(that1.ContainerMetricsEntry[i]) {
			return false
		}
	}
	return true
}
func (this *Capacity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&vcontainermodels.Capacity{")
	s = append(s, "MemoryInBytes: "+fmt.Sprintf("%#v", this.MemoryInBytes)+",\n")
	s = append(s, "DiskInBytes: "+fmt.Sprintf("%#v", this.DiskInBytes)+",\n")
	s = append(s, "MaxContainers: "+fmt.Sprintf("%#v", this.MaxContainers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&vcontainermodels.ContainerSpec{")
	s = append(s, "Handle: "+fmt.Sprintf("%#v", this.Handle)+",\n")
	if this.GraceTime != nil {
		s = append(s, "GraceTime: "+fmt.Sprintf("%#v", this.GraceTime)+",\n")
	}
	s = append(s, "RootFSPath: "+fmt.Sprintf("%#v", this.RootFSPath)+",\n")
	s = append(s, "Image: "+strings.Replace(this.Image.GoString(), `&`, ``, 1)+",\n")
	if this.BindMounts != nil {
		s = append(s, "BindMounts: "+fmt.Sprintf("%#v", this.BindMounts)+",\n")
	}
	s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	if this.Properties != nil {
		s = append(s, "Properties: "+fmt.Sprintf("%#v", this.Properties)+",\n")
	}
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	s = append(s, "Limits: "+strings.Replace(this.Limits.GoString(), `&`, ``, 1)+",\n")
	if this.NetIn != nil {
		s = append(s, "NetIn: "+fmt.Sprintf("%#v", this.NetIn)+",\n")
	}
	if this.NetOut != nil {
		s = append(s, "NetOut: "+fmt.Sprintf("%#v", this.NetOut)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Limits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&vcontainermodels.Limits{")
	s = append(s, "Bandwidth: "+strings.Replace(this.Bandwidth.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "CPU: "+strings.Replace(this.CPU.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Disk: "+strings.Replace(this.Disk.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Memory: "+strings.Replace(this.Memory.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Pid: "+strings.Replace(this.Pid.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerInfoEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.ContainerInfoEntry{")
	s = append(s, "Info: "+strings.Replace(this.Info.GoString(), `&`, ``, 1)+",\n")
	if this.Err != nil {
		s = append(s, "Err: "+fmt.Sprintf("%#v", this.Err)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BulkInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.BulkInfoRequest{")
	s = append(s, "Handles: "+fmt.Sprintf("%#v", this.Handles)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BulkInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.BulkInfoResponse{")
	keysForContainerInfoEntry := make([]string, 0, len(this.ContainerInfoEntry))
	for k, _ := range this.ContainerInfoEntry {
		keysForContainerInfoEntry = append(keysForContainerInfoEntry, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainerInfoEntry)
	mapStringForContainerInfoEntry := "map[string]*ContainerInfoEntry{"
	for _, k := range keysForContainerInfoEntry {
		mapStringForContainerInfoEntry += fmt.Sprintf("%#v: %#v,", k, this.ContainerInfoEntry[k])
	}
	mapStringForContainerInfoEntry += "}"
	if this.ContainerInfoEntry != nil {
		s = append(s, "ContainerInfoEntry: "+mapStringForContainerInfoEntry+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerMetricsEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.ContainerMetricsEntry{")
	s = append(s, "Metrics: "+strings.Replace(this.Metrics.GoString(), `&`, ``, 1)+",\n")
	if this.Err != nil {
		s = append(s, "Err: "+fmt.Sprintf("%#v", this.Err)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BulkMetricsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.BulkMetricsRequest{")
	s = append(s, "Handles: "+fmt.Sprintf("%#v", this.Handles)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BulkMetricsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.BulkMetricsResponse{")
	keysForContainerMetricsEntry := make([]string, 0, len(this.ContainerMetricsEntry))
	for k, _ := range this.ContainerMetricsEntry {
		keysForContainerMetricsEntry = append(keysForContainerMetricsEntry, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainerMetricsEntry)
	mapStringForContainerMetricsEntry := "map[string]*ContainerMetricsEntry{"
	for _, k := range keysForContainerMetricsEntry {
		mapStringForContainerMetricsEntry += fmt.Sprintf("%#v: %#v,", k, this.ContainerMetricsEntry[k])
	}
	mapStringForContainerMetricsEntry += "}"
	if this.ContainerMetricsEntry != nil {
		s = append(s, "ContainerMetricsEntry: "+mapStringForContainerMetricsEntry+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringGarden(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Capacity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Capacity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemoryInBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGarden(dAtA, i, uint64(m.MemoryInBytes))
	}
	if m.DiskInBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGarden(dAtA, i, uint64(m.DiskInBytes))
	}
	if m.MaxContainers != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGarden(dAtA, i, uint64(m.MaxContainers))
	}
	return i, nil
}

func (m *ContainerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Handle) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGarden(dAtA, i, uint64(len(m.Handle)))
		i += copy(dAtA[i:], m.Handle)
	}
	if m.GraceTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGarden(dAtA, i, uint64(m.GraceTime.Size()))
		n1, err := m.GraceTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.RootFSPath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGarden(dAtA, i, uint64(len(m.RootFSPath)))
		i += copy(dAtA[i:], m.RootFSPath)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintGarden(dAtA, i, uint64(m.Image.Size()))
	n2, err := m.Image.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.BindMounts) > 0 {
		for _, msg := range m.BindMounts {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintGarden(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Network) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGarden(dAtA, i, uint64(len(m.Network)))
		i += copy(dAtA[i:], m.Network)
	}
	if m.Properties != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGarden(dAtA, i, uint64(m.Properties.Size()))
		n3, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Privileged {
		dAtA[i] = 0x48
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintGarden(dAtA, i, uint64(m.Limits.Size()))
	n4, err := m.Limits.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.NetIn) > 0 {
		for _, msg := range m.NetIn {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintGarden(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetOut) > 0 {
		for _, msg := range m.NetOut {
			dAtA[i] = 0x62
			i++
			i = encodeVarintGarden(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Limits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintGarden(dAtA, i, uint64(m.Bandwidth.Size()))
	n5, err := m.Bandwidth.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintGarden(dAtA, i, uint64(m.CPU.Size()))
	n6, err := m.CPU.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintGarden(dAtA, i, uint64(m.Disk.Size()))
	n7, err := m.Disk.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintGarden(dAtA, i, uint64(m.Memory.Size()))
	n8, err := m.Memory.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x2a
	i++
	i = encodeVarintGarden(dAtA, i, uint64(m.Pid.Size()))
	n9, err := m.Pid.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *ContainerInfoEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerInfoEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintGarden(dAtA, i, uint64(m.Info.Size()))
	n10, err := m.Info.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if m.Err != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGarden(dAtA, i, uint64(m.Err.Size()))
		n11, err := m.Err.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *BulkInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Handles) > 0 {
		for _, s := range m.Handles {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *BulkInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerInfoEntry) > 0 {
		for k, _ := range m.ContainerInfoEntry {
			dAtA[i] = 0xa
			i++
			v := m.ContainerInfoEntry[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGarden(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGarden(uint64(len(k))) + msgSize
			i = encodeVarintGarden(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGarden(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGarden(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	return i, nil
}

func (m *ContainerMetricsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerMetricsEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintGarden(dAtA, i, uint64(m.Metrics.Size()))
	n13, err := m.Metrics.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if m.Err != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGarden(dAtA, i, uint64(m.Err.Size()))
		n14, err := m.Err.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *BulkMetricsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkMetricsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Handles) > 0 {
		for _, s := range m.Handles {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *BulkMetricsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkMetricsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerMetricsEntry) > 0 {
		for k, _ := range m.ContainerMetricsEntry {
			dAtA[i] = 0xa
			i++
			v := m.ContainerMetricsEntry[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGarden(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGarden(uint64(len(k))) + msgSize
			i = encodeVarintGarden(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGarden(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGarden(dAtA, i, uint64(v.Size()))
				n15, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n15
			}
		}
	}
	return i, nil
}

func encodeFixed64Garden(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Garden(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGarden(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Capacity) Size() (n int) {
	var l int
	_ = l
	if m.MemoryInBytes != 0 {
		n += 1 + sovGarden(uint64(m.MemoryInBytes))
	}
	if m.DiskInBytes != 0 {
		n += 1 + sovGarden(uint64(m.DiskInBytes))
	}
	if m.MaxContainers != 0 {
		n += 1 + sovGarden(uint64(m.MaxContainers))
	}
	return n
}

func (m *ContainerSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Handle)
	if l > 0 {
		n += 1 + l + sovGarden(uint64(l))
	}
	if m.GraceTime != nil {
		l = m.GraceTime.Size()
		n += 1 + l + sovGarden(uint64(l))
	}
	l = len(m.RootFSPath)
	if l > 0 {
		n += 1 + l + sovGarden(uint64(l))
	}
	l = m.Image.Size()
	n += 1 + l + sovGarden(uint64(l))
	if len(m.BindMounts) > 0 {
		for _, e := range m.BindMounts {
			l = e.Size()
			n += 1 + l + sovGarden(uint64(l))
		}
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovGarden(uint64(l))
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovGarden(uint64(l))
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovGarden(uint64(l))
		}
	}
	if m.Privileged {
		n += 2
	}
	l = m.Limits.Size()
	n += 1 + l + sovGarden(uint64(l))
	if len(m.NetIn) > 0 {
		for _, e := range m.NetIn {
			l = e.Size()
			n += 1 + l + sovGarden(uint64(l))
		}
	}
	if len(m.NetOut) > 0 {
		for _, e := range m.NetOut {
			l = e.Size()
			n += 1 + l + sovGarden(uint64(l))
		}
	}
	return n
}

func (m *Limits) Size() (n int) {
	var l int
	_ = l
	l = m.Bandwidth.Size()
	n += 1 + l + sovGarden(uint64(l))
	l = m.CPU.Size()
	n += 1 + l + sovGarden(uint64(l))
	l = m.Disk.Size()
	n += 1 + l + sovGarden(uint64(l))
	l = m.Memory.Size()
	n += 1 + l + sovGarden(uint64(l))
	l = m.Pid.Size()
	n += 1 + l + sovGarden(uint64(l))
	return n
}

func (m *ContainerInfoEntry) Size() (n int) {
	var l int
	_ = l
	l = m.Info.Size()
	n += 1 + l + sovGarden(uint64(l))
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGarden(uint64(l))
	}
	return n
}

func (m *BulkInfoRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Handles) > 0 {
		for _, s := range m.Handles {
			l = len(s)
			n += 1 + l + sovGarden(uint64(l))
		}
	}
	return n
}

func (m *BulkInfoResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ContainerInfoEntry) > 0 {
		for k, v := range m.ContainerInfoEntry {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGarden(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGarden(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGarden(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContainerMetricsEntry) Size() (n int) {
	var l int
	_ = l
	l = m.Metrics.Size()
	n += 1 + l + sovGarden(uint64(l))
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGarden(uint64(l))
	}
	return n
}

func (m *BulkMetricsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Handles) > 0 {
		for _, s := range m.Handles {
			l = len(s)
			n += 1 + l + sovGarden(uint64(l))
		}
	}
	return n
}

func (m *BulkMetricsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ContainerMetricsEntry) > 0 {
		for k, v := range m.ContainerMetricsEntry {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGarden(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGarden(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGarden(uint64(mapEntrySize))
		}
	}
	return n
}

func sovGarden(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGarden(x uint64) (n int) {
	return sovGarden(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Capacity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Capacity{`,
		`MemoryInBytes:` + fmt.Sprintf("%v", this.MemoryInBytes) + `,`,
		`DiskInBytes:` + fmt.Sprintf("%v", this.DiskInBytes) + `,`,
		`MaxContainers:` + fmt.Sprintf("%v", this.MaxContainers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerSpec{`,
		`Handle:` + fmt.Sprintf("%v", this.Handle) + `,`,
		`GraceTime:` + strings.Replace(fmt.Sprintf("%v", this.GraceTime), "Duration", "google_protobuf2.Duration", 1) + `,`,
		`RootFSPath:` + fmt.Sprintf("%v", this.RootFSPath) + `,`,
		`Image:` + strings.Replace(strings.Replace(this.Image.String(), "ImageRef", "ImageRef", 1), `&`, ``, 1) + `,`,
		`BindMounts:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.BindMounts), "BindMount", "BindMount", 1), `&`, ``, 1) + `,`,
		`Network:` + fmt.Sprintf("%v", this.Network) + `,`,
		`Properties:` + strings.Replace(fmt.Sprintf("%v", this.Properties), "Properties", "Properties", 1) + `,`,
		`Env:` + fmt.Sprintf("%v", this.Env) + `,`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`Limits:` + strings.Replace(strings.Replace(this.Limits.String(), "Limits", "Limits", 1), `&`, ``, 1) + `,`,
		`NetIn:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.NetIn), "NetInRequest", "NetInRequest", 1), `&`, ``, 1) + `,`,
		`NetOut:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.NetOut), "NetOutRuleRequest", "NetOutRuleRequest", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Limits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Limits{`,
		`Bandwidth:` + strings.Replace(strings.Replace(this.Bandwidth.String(), "BandwidthLimits", "BandwidthLimits", 1), `&`, ``, 1) + `,`,
		`CPU:` + strings.Replace(strings.Replace(this.CPU.String(), "CPULimits", "CPULimits", 1), `&`, ``, 1) + `,`,
		`Disk:` + strings.Replace(strings.Replace(this.Disk.String(), "DiskLimits", "DiskLimits", 1), `&`, ``, 1) + `,`,
		`Memory:` + strings.Replace(strings.Replace(this.Memory.String(), "MemoryLimits", "MemoryLimits", 1), `&`, ``, 1) + `,`,
		`Pid:` + strings.Replace(strings.Replace(this.Pid.String(), "PidLimits", "PidLimits", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerInfoEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerInfoEntry{`,
		`Info:` + strings.Replace(strings.Replace(this.Info.String(), "ContainerInfo", "ContainerInfo", 1), `&`, ``, 1) + `,`,
		`Err:` + strings.Replace(fmt.Sprintf("%v", this.Err), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BulkInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BulkInfoRequest{`,
		`Handles:` + fmt.Sprintf("%v", this.Handles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BulkInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForContainerInfoEntry := make([]string, 0, len(this.ContainerInfoEntry))
	for k, _ := range this.ContainerInfoEntry {
		keysForContainerInfoEntry = append(keysForContainerInfoEntry, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainerInfoEntry)
	mapStringForContainerInfoEntry := "map[string]*ContainerInfoEntry{"
	for _, k := range keysForContainerInfoEntry {
		mapStringForContainerInfoEntry += fmt.Sprintf("%v: %v,", k, this.ContainerInfoEntry[k])
	}
	mapStringForContainerInfoEntry += "}"
	s := strings.Join([]string{`&BulkInfoResponse{`,
		`ContainerInfoEntry:` + mapStringForContainerInfoEntry + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerMetricsEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerMetricsEntry{`,
		`Metrics:` + strings.Replace(strings.Replace(this.Metrics.String(), "Metrics", "Metrics", 1), `&`, ``, 1) + `,`,
		`Err:` + strings.Replace(fmt.Sprintf("%v", this.Err), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BulkMetricsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BulkMetricsRequest{`,
		`Handles:` + fmt.Sprintf("%v", this.Handles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BulkMetricsResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForContainerMetricsEntry := make([]string, 0, len(this.ContainerMetricsEntry))
	for k, _ := range this.ContainerMetricsEntry {
		keysForContainerMetricsEntry = append(keysForContainerMetricsEntry, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainerMetricsEntry)
	mapStringForContainerMetricsEntry := "map[string]*ContainerMetricsEntry{"
	for _, k := range keysForContainerMetricsEntry {
		mapStringForContainerMetricsEntry += fmt.Sprintf("%v: %v,", k, this.ContainerMetricsEntry[k])
	}
	mapStringForContainerMetricsEntry += "}"
	s := strings.Join([]string{`&BulkMetricsResponse{`,
		`ContainerMetricsEntry:` + mapStringForContainerMetricsEntry + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGarden(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Capacity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Capacity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Capacity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryInBytes", wireType)
			}
			m.MemoryInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryInBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskInBytes", wireType)
			}
			m.DiskInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskInBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxContainers", wireType)
			}
			m.MaxContainers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxContainers |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGarden(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGarden
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraceTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraceTime == nil {
				m.GraceTime = &google_protobuf2.Duration{}
			}
			if err := m.GraceTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootFSPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootFSPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindMounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindMounts = append(m.BindMounts, BindMount{})
			if err := m.BindMounts[len(m.BindMounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &Properties{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetIn = append(m.NetIn, NetInRequest{})
			if err := m.NetIn[len(m.NetIn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetOut = append(m.NetOut, NetOutRuleRequest{})
			if err := m.NetOut[len(m.NetOut)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGarden(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGarden
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Bandwidth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CPU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Disk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGarden(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGarden
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerInfoEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerInfoEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerInfoEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGarden(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGarden
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handles = append(m.Handles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGarden(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGarden
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerInfoEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGarden
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ContainerInfoEntry == nil {
				m.ContainerInfoEntry = make(map[string]*ContainerInfoEntry)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGarden
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGarden
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthGarden
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthGarden
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &ContainerInfoEntry{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.ContainerInfoEntry[mapkey] = mapvalue
			} else {
				var mapvalue *ContainerInfoEntry
				m.ContainerInfoEntry[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGarden(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGarden
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerMetricsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerMetricsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerMetricsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGarden(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGarden
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkMetricsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkMetricsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkMetricsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handles = append(m.Handles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGarden(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGarden
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkMetricsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkMetricsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkMetricsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerMetricsEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGarden
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGarden
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ContainerMetricsEntry == nil {
				m.ContainerMetricsEntry = make(map[string]*ContainerMetricsEntry)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGarden
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGarden
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthGarden
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthGarden
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &ContainerMetricsEntry{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.ContainerMetricsEntry[mapkey] = mapvalue
			} else {
				var mapvalue *ContainerMetricsEntry
				m.ContainerMetricsEntry[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGarden(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGarden
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGarden(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGarden
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGarden
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGarden
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGarden
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGarden(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGarden = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGarden   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("garden.proto", fileDescriptorGarden) }

var fileDescriptorGarden = []byte{
	// 839 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x8e, 0xf3, 0xd7, 0xe6, 0xa4, 0xab, 0xad, 0x06, 0xc1, 0x7a, 0x03, 0xf2, 0x06, 0xb3, 0x12,
	0x91, 0x00, 0x47, 0xca, 0x4a, 0x05, 0xaa, 0x45, 0x62, 0x93, 0x0d, 0x10, 0x89, 0x76, 0x2d, 0x2f,
	0xfb, 0x00, 0x6e, 0x3c, 0x75, 0x87, 0xc4, 0x9e, 0xec, 0x78, 0x9c, 0x36, 0x77, 0x95, 0x78, 0x01,
	0x1e, 0x83, 0x3b, 0x5e, 0x80, 0x07, 0xe8, 0x65, 0x2f, 0xb9, 0x42, 0x34, 0xdc, 0x20, 0x71, 0xd3,
	0x47, 0x40, 0x33, 0x1e, 0x27, 0x76, 0xe3, 0x50, 0x6e, 0xa2, 0x39, 0x67, 0xbe, 0xef, 0xcc, 0x39,
	0xe7, 0x3b, 0xc7, 0x81, 0x3d, 0xdf, 0x65, 0x1e, 0x0e, 0xad, 0x19, 0xa3, 0x9c, 0xa2, 0xfd, 0xf9,
	0x98, 0x86, 0xdc, 0x25, 0x21, 0x66, 0x01, 0xf5, 0xf0, 0x34, 0x6a, 0x19, 0x3e, 0xa5, 0xfe, 0x14,
	0x77, 0xe5, 0xfd, 0x49, 0x7c, 0xda, 0xf5, 0x62, 0xe6, 0x72, 0x42, 0x15, 0xa3, 0xb5, 0x37, 0xa6,
	0x41, 0xb0, 0xb2, 0x1e, 0xae, 0xe8, 0xca, 0xf1, 0x99, 0x4f, 0xf8, 0x59, 0x7c, 0x62, 0x8d, 0x69,
	0xd0, 0xf5, 0xa9, 0x4f, 0xd7, 0x71, 0x84, 0x25, 0x0d, 0x79, 0x4a, 0xe0, 0xe6, 0x05, 0xec, 0x0e,
	0xdc, 0x99, 0x3b, 0x26, 0x7c, 0x81, 0x9e, 0xc2, 0x83, 0x23, 0x1c, 0x50, 0xb6, 0x18, 0x85, 0xfd,
	0x05, 0xc7, 0x91, 0xae, 0xb5, 0xb5, 0x4e, 0xd5, 0xc9, 0x3b, 0x51, 0x1b, 0x9a, 0x2f, 0x49, 0x34,
	0x49, 0x31, 0x65, 0x89, 0xc9, 0xba, 0x64, 0x1c, 0xf7, 0x62, 0x90, 0x26, 0x16, 0xe9, 0x15, 0x15,
	0x27, 0xeb, 0x34, 0x7f, 0xab, 0xc2, 0x83, 0x95, 0xf9, 0x7a, 0x86, 0xc7, 0xe8, 0x3d, 0xa8, 0x7f,
	0xe7, 0x86, 0xde, 0x14, 0xcb, 0x87, 0x1b, 0x8e, 0xb2, 0xd0, 0xe7, 0xd0, 0xf8, 0x96, 0xb9, 0x63,
	0xfc, 0x03, 0x09, 0xb0, 0x7c, 0xaf, 0xd9, 0x7b, 0x6c, 0x25, 0x5d, 0xb2, 0xd2, 0xea, 0xac, 0x97,
	0xaa, 0x4b, 0xce, 0x1a, 0x8b, 0x0c, 0x00, 0x87, 0x52, 0xfe, 0xcd, 0x6b, 0xdb, 0xe5, 0x67, 0x32,
	0x8b, 0x86, 0x93, 0xf1, 0xa0, 0x03, 0xa8, 0x8d, 0x02, 0xd7, 0xc7, 0x7a, 0x55, 0x06, 0x6d, 0x59,
	0x77, 0xc5, 0xb0, 0xe4, 0xb5, 0x83, 0x4f, 0xfb, 0xd5, 0xab, 0x3f, 0x9e, 0x94, 0x9c, 0x04, 0x8e,
	0x5e, 0x00, 0xf4, 0x49, 0xe8, 0x1d, 0xd1, 0x38, 0xe4, 0x91, 0x5e, 0x6b, 0x57, 0x3a, 0xcd, 0xde,
	0xfb, 0x9b, 0xe4, 0x15, 0x46, 0xb1, 0x33, 0x24, 0xa4, 0xc3, 0xce, 0x31, 0xe6, 0xe7, 0x94, 0x4d,
	0xf4, 0xba, 0xcc, 0x2b, 0x35, 0xd1, 0x73, 0x00, 0x9b, 0xd1, 0x19, 0x66, 0x9c, 0xe0, 0x48, 0xdf,
	0x91, 0x99, 0x7d, 0xb0, 0x19, 0x7c, 0x8d, 0x71, 0x32, 0x78, 0xb4, 0x0f, 0x95, 0x61, 0x38, 0xd7,
	0x77, 0xdb, 0x95, 0x4e, 0xc3, 0x11, 0x47, 0xd1, 0x04, 0x9b, 0x91, 0x39, 0x99, 0x62, 0x1f, 0x7b,
	0x7a, 0xa3, 0xad, 0x75, 0x76, 0x9d, 0x8c, 0x07, 0x1d, 0x40, 0xfd, 0x7b, 0x12, 0x10, 0x1e, 0xe9,
	0x20, 0xdf, 0xd2, 0x37, 0xdf, 0x4a, 0xee, 0x55, 0x15, 0x0a, 0x8d, 0x0e, 0xa1, 0x76, 0x8c, 0xf9,
	0x28, 0xd4, 0x9b, 0xb2, 0x7e, 0x63, 0x93, 0x26, 0xaf, 0x1d, 0xfc, 0x36, 0xc6, 0x51, 0xda, 0x82,
	0x84, 0x82, 0x5e, 0x40, 0xfd, 0x18, 0xf3, 0x57, 0x31, 0xd7, 0xf7, 0x24, 0xf9, 0xa3, 0x42, 0xf2,
	0xab, 0x98, 0x3b, 0xf1, 0x14, 0xe7, 0x23, 0x28, 0xa2, 0xf9, 0x6b, 0x39, 0xcd, 0x1b, 0x0d, 0xa1,
	0xd1, 0x77, 0x43, 0xef, 0x9c, 0x78, 0xfc, 0x4c, 0x8e, 0x4e, 0xb3, 0xf7, 0x61, 0x81, 0x1a, 0x29,
	0x24, 0x57, 0xcd, 0x9a, 0x89, 0x9e, 0x41, 0x65, 0x60, 0xbf, 0x51, 0x03, 0x56, 0x20, 0xe7, 0xc0,
	0x7e, 0x93, 0xa3, 0x0a, 0x34, 0x3a, 0x80, 0xaa, 0x18, 0x7d, 0x39, 0x5c, 0x85, 0x3a, 0x89, 0xdb,
	0x1c, 0x4d, 0xe2, 0xd1, 0x73, 0xa8, 0x27, 0x6b, 0xa5, 0x66, 0xaf, 0xa0, 0x7d, 0xc9, 0x7d, 0xbe,
	0xf7, 0x89, 0x4f, 0xa4, 0x6a, 0x13, 0x4f, 0xaf, 0x6d, 0x4b, 0xd5, 0x26, 0x5e, 0x3e, 0x55, 0x9b,
	0x78, 0xe6, 0xa5, 0x06, 0x68, 0xb5, 0x70, 0xa3, 0xf0, 0x94, 0x0e, 0x43, 0xce, 0x16, 0xe8, 0x4b,
	0xa8, 0x0a, 0x43, 0x35, 0xee, 0x49, 0x41, 0xdd, 0x59, 0x4e, 0x5a, 0x84, 0x38, 0xa3, 0x2e, 0x54,
	0x86, 0x8c, 0xa9, 0x8e, 0x3d, 0xda, 0x64, 0x0e, 0x19, 0xa3, 0x4c, 0x32, 0x34, 0x47, 0x20, 0xcd,
	0x4f, 0xe0, 0x61, 0x3f, 0x9e, 0x4e, 0x04, 0x59, 0xa9, 0x2a, 0x16, 0x21, 0x59, 0x73, 0xf1, 0xb9,
	0x11, 0x43, 0x9b, 0x9a, 0xe6, 0x3f, 0x1a, 0xec, 0xaf, 0xd1, 0xd1, 0x8c, 0x86, 0x11, 0x46, 0x3f,
	0x16, 0xd5, 0x20, 0x99, 0xcd, 0xde, 0x61, 0x81, 0xe8, 0x77, 0xf8, 0xd6, 0x26, 0x59, 0xfe, 0x38,
	0x05, 0x51, 0x5b, 0x13, 0x78, 0xb4, 0x05, 0x2e, 0xd6, 0x6c, 0x82, 0x17, 0xea, 0x3b, 0x25, 0x8e,
	0x62, 0x1d, 0xe6, 0xee, 0x34, 0x4e, 0x3f, 0x50, 0x4f, 0xef, 0xe9, 0x63, 0xf2, 0x6a, 0x42, 0x39,
	0x2c, 0x7f, 0xa1, 0x99, 0x3f, 0x69, 0xf0, 0xee, 0x0a, 0x71, 0x84, 0x39, 0x23, 0xe3, 0x28, 0x15,
	0x68, 0x47, 0xd9, 0x4a, 0xa3, 0xc7, 0x45, 0xb3, 0x22, 0x01, 0x4a, 0x9d, 0x14, 0x2f, 0x04, 0xc2,
	0xff, 0x5b, 0x20, 0xcc, 0x98, 0x69, 0x01, 0x12, 0x2d, 0x53, 0xfc, 0xfb, 0x35, 0xba, 0x2c, 0xc3,
	0x3b, 0x39, 0x82, 0x92, 0x69, 0xbe, 0xa5, 0x18, 0xa5, 0xd4, 0xd7, 0xc5, 0x4a, 0xdd, 0x89, 0x62,
	0x15, 0x86, 0x48, 0x3a, 0x57, 0x1c, 0xbe, 0xf5, 0x16, 0x5a, 0xdb, 0x49, 0x05, 0xaa, 0x7d, 0x95,
	0x57, 0xed, 0xe3, 0xff, 0x50, 0x2d, 0x1b, 0x2e, 0x23, 0x5c, 0xff, 0xd3, 0xeb, 0x1b, 0xa3, 0xf4,
	0xfb, 0x8d, 0x51, 0xba, 0xbd, 0x31, 0xb4, 0xcb, 0xa5, 0xa1, 0xfd, 0xb2, 0x34, 0xb4, 0xab, 0xa5,
	0xa1, 0x5d, 0x2f, 0x0d, 0xed, 0xcf, 0xa5, 0xa1, 0xfd, 0xbd, 0x34, 0x4a, 0xb7, 0x4b, 0x43, 0xfb,
	0xf9, 0x2f, 0xa3, 0x74, 0x52, 0x97, 0x7f, 0x58, 0xcf, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x61,
	0x19, 0xea, 0x20, 0x06, 0x08, 0x00, 0x00,
}
