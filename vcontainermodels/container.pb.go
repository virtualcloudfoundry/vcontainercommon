// Code generated by protoc-gen-gogo.
// source: container.proto
// DO NOT EDIT!

package vcontainermodels

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf1 "github.com/gogo/protobuf/types"
import _ "github.com/gogo/protobuf/gogoproto"

import strconv "strconv"

import bytes "bytes"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DiskLimitScope int32

const (
	DiskLimitScopeTotal     DiskLimitScope = 0
	DiskLimitScopeExclusive DiskLimitScope = 1
)

var DiskLimitScope_name = map[int32]string{
	0: "DiskLimitScopeTotal",
	1: "DiskLimitScopeExclusive",
}
var DiskLimitScope_value = map[string]int32{
	"DiskLimitScopeTotal":     0,
	"DiskLimitScopeExclusive": 1,
}

func (DiskLimitScope) EnumDescriptor() ([]byte, []int) { return fileDescriptorContainer, []int{0} }

type ProcessSpec struct {
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Path to command to execute.
	Path string `protobuf:"bytes,2,opt,name=Path,proto3" json:"Path,omitempty"`
	// Arguments to pass to command.
	Args []string `protobuf:"bytes,3,rep,name=Args" json:"Args,omitempty"`
	// Environment variables.
	Env []string `protobuf:"bytes,4,rep,name=Env" json:"Env,omitempty"`
	// Working directory (default: home directory).
	Dir string `protobuf:"bytes,5,opt,name=Dir,proto3" json:"Dir,omitempty"`
	// The name of a user in the container to run the process as.
	// This must either be a username, or uid:gid.
	User string `protobuf:"bytes,6,opt,name=User,proto3" json:"User,omitempty"`
	// Resource limits
	Limits                  ResourceLimits `protobuf:"bytes,7,opt,name=Limits" json:"Limits"`
	OverrideContainerLimits ProcessLimits  `protobuf:"bytes,8,opt,name=OverrideContainerLimits" json:"OverrideContainerLimits"`
	// Execute with a TTY for stdio.
	TTY TTYSpec `protobuf:"bytes,9,opt,name=TTY" json:"TTY"`
	// Execute process in own root filesystem, different from the other processes
	// in the container.
	Image      ImageRef    `protobuf:"bytes,10,opt,name=Image" json:"Image"`
	BindMounts []BindMount `protobuf:"bytes,11,rep,name=BindMounts" json:"BindMounts"`
}

func (m *ProcessSpec) Reset()                    { *m = ProcessSpec{} }
func (*ProcessSpec) ProtoMessage()               {}
func (*ProcessSpec) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{0} }

func (m *ProcessSpec) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ProcessSpec) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ProcessSpec) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ProcessSpec) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *ProcessSpec) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *ProcessSpec) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *ProcessSpec) GetLimits() ResourceLimits {
	if m != nil {
		return m.Limits
	}
	return ResourceLimits{}
}

func (m *ProcessSpec) GetOverrideContainerLimits() ProcessLimits {
	if m != nil {
		return m.OverrideContainerLimits
	}
	return ProcessLimits{}
}

func (m *ProcessSpec) GetTTY() TTYSpec {
	if m != nil {
		return m.TTY
	}
	return TTYSpec{}
}

func (m *ProcessSpec) GetImage() ImageRef {
	if m != nil {
		return m.Image
	}
	return ImageRef{}
}

func (m *ProcessSpec) GetBindMounts() []BindMount {
	if m != nil {
		return m.BindMounts
	}
	return nil
}

type RunResponse struct {
	ID        string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ProcessId string `protobuf:"bytes,2,opt,name=ProcessId,proto3" json:"ProcessId,omitempty"`
}

func (m *RunResponse) Reset()                    { *m = RunResponse{} }
func (*RunResponse) ProtoMessage()               {}
func (*RunResponse) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{1} }

func (m *RunResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *RunResponse) GetProcessId() string {
	if m != nil {
		return m.ProcessId
	}
	return ""
}

type TTYSpec struct {
	WindowSize WindowSize `protobuf:"bytes,1,opt,name=WindowSize" json:"WindowSize"`
}

func (m *TTYSpec) Reset()                    { *m = TTYSpec{} }
func (*TTYSpec) ProtoMessage()               {}
func (*TTYSpec) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{2} }

func (m *TTYSpec) GetWindowSize() WindowSize {
	if m != nil {
		return m.WindowSize
	}
	return WindowSize{}
}

type WindowSize struct {
	Columns int32 `protobuf:"varint,1,opt,name=Columns,proto3" json:"Columns,omitempty"`
	Rows    int32 `protobuf:"varint,2,opt,name=Rows,proto3" json:"Rows,omitempty"`
}

func (m *WindowSize) Reset()                    { *m = WindowSize{} }
func (*WindowSize) ProtoMessage()               {}
func (*WindowSize) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{3} }

func (m *WindowSize) GetColumns() int32 {
	if m != nil {
		return m.Columns
	}
	return 0
}

func (m *WindowSize) GetRows() int32 {
	if m != nil {
		return m.Rows
	}
	return 0
}

type ResourceLimits struct {
	As *google_protobuf1.UInt64Value `protobuf:"bytes,1,opt,name=As" json:"As,omitempty"`
}

func (m *ResourceLimits) Reset()                    { *m = ResourceLimits{} }
func (*ResourceLimits) ProtoMessage()               {}
func (*ResourceLimits) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{4} }

func (m *ResourceLimits) GetAs() *google_protobuf1.UInt64Value {
	if m != nil {
		return m.As
	}
	return nil
}

type BandwidthLimits struct {
	RateInBytesPerSecond      uint64 `protobuf:"varint,1,opt,name=RateInBytesPerSecond,proto3" json:"RateInBytesPerSecond,omitempty"`
	BurstRateInBytesPerSecond uint64 `protobuf:"varint,2,opt,name=BurstRateInBytesPerSecond,proto3" json:"BurstRateInBytesPerSecond,omitempty"`
}

func (m *BandwidthLimits) Reset()                    { *m = BandwidthLimits{} }
func (*BandwidthLimits) ProtoMessage()               {}
func (*BandwidthLimits) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{5} }

func (m *BandwidthLimits) GetRateInBytesPerSecond() uint64 {
	if m != nil {
		return m.RateInBytesPerSecond
	}
	return 0
}

func (m *BandwidthLimits) GetBurstRateInBytesPerSecond() uint64 {
	if m != nil {
		return m.BurstRateInBytesPerSecond
	}
	return 0
}

type ProcessLimits struct {
	CPU    CPULimits    `protobuf:"bytes,1,opt,name=CPU" json:"CPU"`
	Memory MemoryLimits `protobuf:"bytes,2,opt,name=Memory" json:"Memory"`
}

func (m *ProcessLimits) Reset()                    { *m = ProcessLimits{} }
func (*ProcessLimits) ProtoMessage()               {}
func (*ProcessLimits) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{6} }

func (m *ProcessLimits) GetCPU() CPULimits {
	if m != nil {
		return m.CPU
	}
	return CPULimits{}
}

func (m *ProcessLimits) GetMemory() MemoryLimits {
	if m != nil {
		return m.Memory
	}
	return MemoryLimits{}
}

type DiskLimits struct {
	InodeSoft uint64         `protobuf:"varint,1,opt,name=InodeSoft,proto3" json:"InodeSoft,omitempty"`
	InodeHard uint64         `protobuf:"varint,2,opt,name=InodeHard,proto3" json:"InodeHard,omitempty"`
	ByteSoft  uint64         `protobuf:"varint,3,opt,name=ByteSoft,proto3" json:"ByteSoft,omitempty"`
	ByteHard  uint64         `protobuf:"varint,4,opt,name=ByteHard,proto3" json:"ByteHard,omitempty"`
	Scope     DiskLimitScope `protobuf:"varint,5,opt,name=Scope,proto3,enum=vcontainermodels.DiskLimitScope" json:"Scope,omitempty"`
}

func (m *DiskLimits) Reset()                    { *m = DiskLimits{} }
func (*DiskLimits) ProtoMessage()               {}
func (*DiskLimits) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{7} }

func (m *DiskLimits) GetInodeSoft() uint64 {
	if m != nil {
		return m.InodeSoft
	}
	return 0
}

func (m *DiskLimits) GetInodeHard() uint64 {
	if m != nil {
		return m.InodeHard
	}
	return 0
}

func (m *DiskLimits) GetByteSoft() uint64 {
	if m != nil {
		return m.ByteSoft
	}
	return 0
}

func (m *DiskLimits) GetByteHard() uint64 {
	if m != nil {
		return m.ByteHard
	}
	return 0
}

func (m *DiskLimits) GetScope() DiskLimitScope {
	if m != nil {
		return m.Scope
	}
	return DiskLimitScopeTotal
}

type MemoryLimits struct {
	LimitInBytes uint64 `protobuf:"varint,1,opt,name=LimitInBytes,proto3" json:"LimitInBytes,omitempty"`
}

func (m *MemoryLimits) Reset()                    { *m = MemoryLimits{} }
func (*MemoryLimits) ProtoMessage()               {}
func (*MemoryLimits) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{8} }

func (m *MemoryLimits) GetLimitInBytes() uint64 {
	if m != nil {
		return m.LimitInBytes
	}
	return 0
}

type CPULimits struct {
	LimitInShares uint64 `protobuf:"varint,1,opt,name=LimitInShares,proto3" json:"LimitInShares,omitempty"`
}

func (m *CPULimits) Reset()                    { *m = CPULimits{} }
func (*CPULimits) ProtoMessage()               {}
func (*CPULimits) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{9} }

func (m *CPULimits) GetLimitInShares() uint64 {
	if m != nil {
		return m.LimitInShares
	}
	return 0
}

type PidLimits struct {
	// Limits the number of pids a container may create before new forks or clones are disallowed to processes in the container.
	// Note: this may only be enforced when a process attempts to fork, so it does not guarantee that a new container.Run(ProcessSpec)
	// will not succeed even if the limit has been exceeded, but the process will not be able to spawn further processes or threads.
	Max uint64 `protobuf:"varint,1,opt,name=Max,proto3" json:"Max,omitempty"`
}

func (m *PidLimits) Reset()                    { *m = PidLimits{} }
func (*PidLimits) ProtoMessage()               {}
func (*PidLimits) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{10} }

func (m *PidLimits) GetMax() uint64 {
	if m != nil {
		return m.Max
	}
	return 0
}

type PortMapping struct {
	HostPort      uint32 `protobuf:"varint,1,opt,name=HostPort,proto3" json:"HostPort,omitempty"`
	ContainerPort uint32 `protobuf:"varint,2,opt,name=ContainerPort,proto3" json:"ContainerPort,omitempty"`
}

func (m *PortMapping) Reset()                    { *m = PortMapping{} }
func (*PortMapping) ProtoMessage()               {}
func (*PortMapping) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{11} }

func (m *PortMapping) GetHostPort() uint32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *PortMapping) GetContainerPort() uint32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

type StreamInSpec struct {
	// Types that are valid to be assigned to Part:
	//	*StreamInSpec_Path
	//	*StreamInSpec_User
	//	*StreamInSpec_Content
	Part isStreamInSpec_Part `protobuf_oneof:"Part"`
}

func (m *StreamInSpec) Reset()                    { *m = StreamInSpec{} }
func (*StreamInSpec) ProtoMessage()               {}
func (*StreamInSpec) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{12} }

type isStreamInSpec_Part interface {
	isStreamInSpec_Part()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StreamInSpec_Path struct {
	Path string `protobuf:"bytes,1,opt,name=Path,proto3,oneof"`
}
type StreamInSpec_User struct {
	User string `protobuf:"bytes,2,opt,name=User,proto3,oneof"`
}
type StreamInSpec_Content struct {
	Content []byte `protobuf:"bytes,3,opt,name=Content,proto3,oneof"`
}

func (*StreamInSpec_Path) isStreamInSpec_Part()    {}
func (*StreamInSpec_User) isStreamInSpec_Part()    {}
func (*StreamInSpec_Content) isStreamInSpec_Part() {}

func (m *StreamInSpec) GetPart() isStreamInSpec_Part {
	if m != nil {
		return m.Part
	}
	return nil
}

func (m *StreamInSpec) GetPath() string {
	if x, ok := m.GetPart().(*StreamInSpec_Path); ok {
		return x.Path
	}
	return ""
}

func (m *StreamInSpec) GetUser() string {
	if x, ok := m.GetPart().(*StreamInSpec_User); ok {
		return x.User
	}
	return ""
}

func (m *StreamInSpec) GetContent() []byte {
	if x, ok := m.GetPart().(*StreamInSpec_Content); ok {
		return x.Content
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StreamInSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StreamInSpec_OneofMarshaler, _StreamInSpec_OneofUnmarshaler, _StreamInSpec_OneofSizer, []interface{}{
		(*StreamInSpec_Path)(nil),
		(*StreamInSpec_User)(nil),
		(*StreamInSpec_Content)(nil),
	}
}

func _StreamInSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StreamInSpec)
	// Part
	switch x := m.Part.(type) {
	case *StreamInSpec_Path:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Path)
	case *StreamInSpec_User:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.User)
	case *StreamInSpec_Content:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Content)
	case nil:
	default:
		return fmt.Errorf("StreamInSpec.Part has unexpected type %T", x)
	}
	return nil
}

func _StreamInSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StreamInSpec)
	switch tag {
	case 1: // Part.Path
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Part = &StreamInSpec_Path{x}
		return true, err
	case 2: // Part.User
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Part = &StreamInSpec_User{x}
		return true, err
	case 3: // Part.Content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Part = &StreamInSpec_Content{x}
		return true, err
	default:
		return false, nil
	}
}

func _StreamInSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StreamInSpec)
	// Part
	switch x := m.Part.(type) {
	case *StreamInSpec_Path:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Path)))
		n += len(x.Path)
	case *StreamInSpec_User:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.User)))
		n += len(x.User)
	case *StreamInSpec_Content:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Content)))
		n += len(x.Content)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StreamInResponse struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *StreamInResponse) Reset()                    { *m = StreamInResponse{} }
func (*StreamInResponse) ProtoMessage()               {}
func (*StreamInResponse) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{13} }

func (m *StreamInResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type StreamOutSpec struct {
	Path string `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	User string `protobuf:"bytes,2,opt,name=User,proto3" json:"User,omitempty"`
}

func (m *StreamOutSpec) Reset()                    { *m = StreamOutSpec{} }
func (*StreamOutSpec) ProtoMessage()               {}
func (*StreamOutSpec) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{14} }

func (m *StreamOutSpec) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *StreamOutSpec) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type StreamOutResponse struct {
	Content []byte `protobuf:"bytes,1,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *StreamOutResponse) Reset()                    { *m = StreamOutResponse{} }
func (*StreamOutResponse) ProtoMessage()               {}
func (*StreamOutResponse) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{15} }

func (m *StreamOutResponse) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type ContainerInfo struct {
	State         string        `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Events        []string      `protobuf:"bytes,2,rep,name=Events" json:"Events,omitempty"`
	HostIP        string        `protobuf:"bytes,3,opt,name=HostIP,proto3" json:"HostIP,omitempty"`
	ContainerIP   string        `protobuf:"bytes,4,opt,name=ContainerIP,proto3" json:"ContainerIP,omitempty"`
	ExternalIP    string        `protobuf:"bytes,5,opt,name=ExternalIP,proto3" json:"ExternalIP,omitempty"`
	ContainerPath string        `protobuf:"bytes,6,opt,name=ContainerPath,proto3" json:"ContainerPath,omitempty"`
	ProcessIDs    []string      `protobuf:"bytes,7,rep,name=ProcessIDs" json:"ProcessIDs,omitempty"`
	Properties    *Properties   `protobuf:"bytes,8,opt,name=Properties" json:"Properties,omitempty"`
	MappedPorts   []PortMapping `protobuf:"bytes,9,rep,name=MappedPorts" json:"MappedPorts"`
}

func (m *ContainerInfo) Reset()                    { *m = ContainerInfo{} }
func (*ContainerInfo) ProtoMessage()               {}
func (*ContainerInfo) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{16} }

func (m *ContainerInfo) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *ContainerInfo) GetEvents() []string {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *ContainerInfo) GetHostIP() string {
	if m != nil {
		return m.HostIP
	}
	return ""
}

func (m *ContainerInfo) GetContainerIP() string {
	if m != nil {
		return m.ContainerIP
	}
	return ""
}

func (m *ContainerInfo) GetExternalIP() string {
	if m != nil {
		return m.ExternalIP
	}
	return ""
}

func (m *ContainerInfo) GetContainerPath() string {
	if m != nil {
		return m.ContainerPath
	}
	return ""
}

func (m *ContainerInfo) GetProcessIDs() []string {
	if m != nil {
		return m.ProcessIDs
	}
	return nil
}

func (m *ContainerInfo) GetProperties() *Properties {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *ContainerInfo) GetMappedPorts() []PortMapping {
	if m != nil {
		return m.MappedPorts
	}
	return nil
}

type Metrics struct {
	MemoryStat  *ContainerMemoryStat  `protobuf:"bytes,1,opt,name=MemoryStat" json:"MemoryStat,omitempty"`
	CPUStat     *ContainerCPUStat     `protobuf:"bytes,2,opt,name=CPUStat" json:"CPUStat,omitempty"`
	DiskStat    *ContainerDiskStat    `protobuf:"bytes,3,opt,name=DiskStat" json:"DiskStat,omitempty"`
	NetworkStat *ContainerNetworkStat `protobuf:"bytes,4,opt,name=NetworkStat" json:"NetworkStat,omitempty"`
}

func (m *Metrics) Reset()                    { *m = Metrics{} }
func (*Metrics) ProtoMessage()               {}
func (*Metrics) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{17} }

func (m *Metrics) GetMemoryStat() *ContainerMemoryStat {
	if m != nil {
		return m.MemoryStat
	}
	return nil
}

func (m *Metrics) GetCPUStat() *ContainerCPUStat {
	if m != nil {
		return m.CPUStat
	}
	return nil
}

func (m *Metrics) GetDiskStat() *ContainerDiskStat {
	if m != nil {
		return m.DiskStat
	}
	return nil
}

func (m *Metrics) GetNetworkStat() *ContainerNetworkStat {
	if m != nil {
		return m.NetworkStat
	}
	return nil
}

type ContainerMemoryStat struct {
	ActiveAnon              uint64 `protobuf:"varint,1,opt,name=ActiveAnon,proto3" json:"active_anon"`
	ActiveFile              uint64 `protobuf:"varint,2,opt,name=ActiveFile,proto3" json:"active_file"`
	Cache                   uint64 `protobuf:"varint,3,opt,name=Cache,proto3" json:"cache"`
	HierarchicalMemoryLimit uint64 `protobuf:"varint,4,opt,name=HierarchicalMemoryLimit,proto3" json:"hierarchical_memory_limit"`
	InactiveAnon            uint64 `protobuf:"varint,5,opt,name=InactiveAnon,proto3" json:"inactive_anon"`
	InactiveFile            uint64 `protobuf:"varint,6,opt,name=InactiveFile,proto3" json:"inactive_file"`
	MappedFile              uint64 `protobuf:"varint,7,opt,name=MappedFile,proto3" json:"mapped_file"`
	Pgfault                 uint64 `protobuf:"varint,8,opt,name=Pgfault,proto3" json:"pgfault"`
	Pgmajfault              uint64 `protobuf:"varint,9,opt,name=Pgmajfault,proto3" json:"pgmajfault"`
	Pgpgin                  uint64 `protobuf:"varint,10,opt,name=Pgpgin,proto3" json:"pgpgin"`
	Pgpgout                 uint64 `protobuf:"varint,11,opt,name=Pgpgout,proto3" json:"pgpgout"`
	Rss                     uint64 `protobuf:"varint,12,opt,name=Rss,proto3" json:"rss"`
	TotalActiveAnon         uint64 `protobuf:"varint,13,opt,name=TotalActiveAnon,proto3" json:"total_active_anon"`
	TotalActiveFile         uint64 `protobuf:"varint,14,opt,name=TotalActiveFile,proto3" json:"total_active_file"`
	TotalCache              uint64 `protobuf:"varint,15,opt,name=TotalCache,proto3" json:"total_cache"`
	TotalInactiveAnon       uint64 `protobuf:"varint,16,opt,name=TotalInactiveAnon,proto3" json:"total_inactive_anon"`
	TotalInactiveFile       uint64 `protobuf:"varint,17,opt,name=TotalInactiveFile,proto3" json:"total_inactive_file"`
	TotalMappedFile         uint64 `protobuf:"varint,18,opt,name=TotalMappedFile,proto3" json:"total_mapped_file"`
	TotalPgfault            uint64 `protobuf:"varint,19,opt,name=TotalPgfault,proto3" json:"total_pgfault"`
	TotalPgmajfault         uint64 `protobuf:"varint,20,opt,name=TotalPgmajfault,proto3" json:"total_pgmajfault"`
	TotalPgpgin             uint64 `protobuf:"varint,21,opt,name=TotalPgpgin,proto3" json:"total_pgpgin"`
	TotalPgpgout            uint64 `protobuf:"varint,22,opt,name=TotalPgpgout,proto3" json:"total_pgpgout"`
	TotalRss                uint64 `protobuf:"varint,23,opt,name=TotalRss,proto3" json:"total_rss"`
	TotalUnevictable        uint64 `protobuf:"varint,24,opt,name=TotalUnevictable,proto3" json:"total_unevictable"`
	Unevictable             uint64 `protobuf:"varint,25,opt,name=Unevictable,proto3" json:"unevictable"`
	Swap                    uint64 `protobuf:"varint,26,opt,name=Swap,proto3" json:"swap"`
	HierarchicalMemswLimit  uint64 `protobuf:"varint,27,opt,name=HierarchicalMemswLimit,proto3" json:"hierarchical_memsw_limit"`
	TotalSwap               uint64 `protobuf:"varint,28,opt,name=TotalSwap,proto3" json:"total_swap"`
	//   A memory usage total which reports memory usage in the same way that limits are enforced.
	//   This value includes memory consumed by nested containers.
	TotalUsageTowardLimit uint64 `protobuf:"varint,29,opt,name=TotalUsageTowardLimit,proto3" json:"TotalUsageTowardLimit,omitempty"`
}

func (m *ContainerMemoryStat) Reset()                    { *m = ContainerMemoryStat{} }
func (*ContainerMemoryStat) ProtoMessage()               {}
func (*ContainerMemoryStat) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{18} }

func (m *ContainerMemoryStat) GetActiveAnon() uint64 {
	if m != nil {
		return m.ActiveAnon
	}
	return 0
}

func (m *ContainerMemoryStat) GetActiveFile() uint64 {
	if m != nil {
		return m.ActiveFile
	}
	return 0
}

func (m *ContainerMemoryStat) GetCache() uint64 {
	if m != nil {
		return m.Cache
	}
	return 0
}

func (m *ContainerMemoryStat) GetHierarchicalMemoryLimit() uint64 {
	if m != nil {
		return m.HierarchicalMemoryLimit
	}
	return 0
}

func (m *ContainerMemoryStat) GetInactiveAnon() uint64 {
	if m != nil {
		return m.InactiveAnon
	}
	return 0
}

func (m *ContainerMemoryStat) GetInactiveFile() uint64 {
	if m != nil {
		return m.InactiveFile
	}
	return 0
}

func (m *ContainerMemoryStat) GetMappedFile() uint64 {
	if m != nil {
		return m.MappedFile
	}
	return 0
}

func (m *ContainerMemoryStat) GetPgfault() uint64 {
	if m != nil {
		return m.Pgfault
	}
	return 0
}

func (m *ContainerMemoryStat) GetPgmajfault() uint64 {
	if m != nil {
		return m.Pgmajfault
	}
	return 0
}

func (m *ContainerMemoryStat) GetPgpgin() uint64 {
	if m != nil {
		return m.Pgpgin
	}
	return 0
}

func (m *ContainerMemoryStat) GetPgpgout() uint64 {
	if m != nil {
		return m.Pgpgout
	}
	return 0
}

func (m *ContainerMemoryStat) GetRss() uint64 {
	if m != nil {
		return m.Rss
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalActiveAnon() uint64 {
	if m != nil {
		return m.TotalActiveAnon
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalActiveFile() uint64 {
	if m != nil {
		return m.TotalActiveFile
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalCache() uint64 {
	if m != nil {
		return m.TotalCache
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalInactiveAnon() uint64 {
	if m != nil {
		return m.TotalInactiveAnon
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalInactiveFile() uint64 {
	if m != nil {
		return m.TotalInactiveFile
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalMappedFile() uint64 {
	if m != nil {
		return m.TotalMappedFile
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalPgfault() uint64 {
	if m != nil {
		return m.TotalPgfault
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalPgmajfault() uint64 {
	if m != nil {
		return m.TotalPgmajfault
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalPgpgin() uint64 {
	if m != nil {
		return m.TotalPgpgin
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalPgpgout() uint64 {
	if m != nil {
		return m.TotalPgpgout
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalRss() uint64 {
	if m != nil {
		return m.TotalRss
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalUnevictable() uint64 {
	if m != nil {
		return m.TotalUnevictable
	}
	return 0
}

func (m *ContainerMemoryStat) GetUnevictable() uint64 {
	if m != nil {
		return m.Unevictable
	}
	return 0
}

func (m *ContainerMemoryStat) GetSwap() uint64 {
	if m != nil {
		return m.Swap
	}
	return 0
}

func (m *ContainerMemoryStat) GetHierarchicalMemswLimit() uint64 {
	if m != nil {
		return m.HierarchicalMemswLimit
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalSwap() uint64 {
	if m != nil {
		return m.TotalSwap
	}
	return 0
}

func (m *ContainerMemoryStat) GetTotalUsageTowardLimit() uint64 {
	if m != nil {
		return m.TotalUsageTowardLimit
	}
	return 0
}

type ContainerCPUStat struct {
	Usage  uint64 `protobuf:"varint,1,opt,name=Usage,proto3" json:"Usage,omitempty"`
	User   uint64 `protobuf:"varint,2,opt,name=User,proto3" json:"User,omitempty"`
	System uint64 `protobuf:"varint,3,opt,name=System,proto3" json:"System,omitempty"`
}

func (m *ContainerCPUStat) Reset()                    { *m = ContainerCPUStat{} }
func (*ContainerCPUStat) ProtoMessage()               {}
func (*ContainerCPUStat) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{19} }

func (m *ContainerCPUStat) GetUsage() uint64 {
	if m != nil {
		return m.Usage
	}
	return 0
}

func (m *ContainerCPUStat) GetUser() uint64 {
	if m != nil {
		return m.User
	}
	return 0
}

func (m *ContainerCPUStat) GetSystem() uint64 {
	if m != nil {
		return m.System
	}
	return 0
}

type ContainerDiskStat struct {
	TotalBytesUsed      uint64 `protobuf:"varint,1,opt,name=TotalBytesUsed,proto3" json:"TotalBytesUsed,omitempty"`
	TotalInodesUsed     uint64 `protobuf:"varint,2,opt,name=TotalInodesUsed,proto3" json:"TotalInodesUsed,omitempty"`
	ExclusiveBytesUsed  uint64 `protobuf:"varint,3,opt,name=ExclusiveBytesUsed,proto3" json:"ExclusiveBytesUsed,omitempty"`
	ExclusiveInodesUsed uint64 `protobuf:"varint,4,opt,name=ExclusiveInodesUsed,proto3" json:"ExclusiveInodesUsed,omitempty"`
}

func (m *ContainerDiskStat) Reset()                    { *m = ContainerDiskStat{} }
func (*ContainerDiskStat) ProtoMessage()               {}
func (*ContainerDiskStat) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{20} }

func (m *ContainerDiskStat) GetTotalBytesUsed() uint64 {
	if m != nil {
		return m.TotalBytesUsed
	}
	return 0
}

func (m *ContainerDiskStat) GetTotalInodesUsed() uint64 {
	if m != nil {
		return m.TotalInodesUsed
	}
	return 0
}

func (m *ContainerDiskStat) GetExclusiveBytesUsed() uint64 {
	if m != nil {
		return m.ExclusiveBytesUsed
	}
	return 0
}

func (m *ContainerDiskStat) GetExclusiveInodesUsed() uint64 {
	if m != nil {
		return m.ExclusiveInodesUsed
	}
	return 0
}

type ContainerNetworkStat struct {
	RxBytes uint64 `protobuf:"varint,1,opt,name=RxBytes,proto3" json:"RxBytes,omitempty"`
	TxBytes uint64 `protobuf:"varint,2,opt,name=TxBytes,proto3" json:"TxBytes,omitempty"`
}

func (m *ContainerNetworkStat) Reset()                    { *m = ContainerNetworkStat{} }
func (*ContainerNetworkStat) ProtoMessage()               {}
func (*ContainerNetworkStat) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{21} }

func (m *ContainerNetworkStat) GetRxBytes() uint64 {
	if m != nil {
		return m.RxBytes
	}
	return 0
}

func (m *ContainerNetworkStat) GetTxBytes() uint64 {
	if m != nil {
		return m.TxBytes
	}
	return 0
}

type StopMessage struct {
	Kill bool `protobuf:"varint,1,opt,name=Kill,proto3" json:"Kill,omitempty"`
}

func (m *StopMessage) Reset()                    { *m = StopMessage{} }
func (*StopMessage) ProtoMessage()               {}
func (*StopMessage) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{22} }

func (m *StopMessage) GetKill() bool {
	if m != nil {
		return m.Kill
	}
	return false
}

type NetInRequest struct {
	HostPort      uint32 `protobuf:"varint,1,opt,name=HostPort,proto3" json:"HostPort,omitempty"`
	ContainerPort uint32 `protobuf:"varint,2,opt,name=ContainerPort,proto3" json:"ContainerPort,omitempty"`
}

func (m *NetInRequest) Reset()                    { *m = NetInRequest{} }
func (*NetInRequest) ProtoMessage()               {}
func (*NetInRequest) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{23} }

func (m *NetInRequest) GetHostPort() uint32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *NetInRequest) GetContainerPort() uint32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

type NetInResponse struct {
	HostPort      uint32 `protobuf:"varint,1,opt,name=HostPort,proto3" json:"HostPort,omitempty"`
	ContainerPort uint32 `protobuf:"varint,2,opt,name=ContainerPort,proto3" json:"ContainerPort,omitempty"`
}

func (m *NetInResponse) Reset()                    { *m = NetInResponse{} }
func (*NetInResponse) ProtoMessage()               {}
func (*NetInResponse) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{24} }

func (m *NetInResponse) GetHostPort() uint32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *NetInResponse) GetContainerPort() uint32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

type IPRange struct {
	Start []byte `protobuf:"bytes,1,opt,name=Start,proto3" json:"start"`
	End   []byte `protobuf:"bytes,2,opt,name=End,proto3" json:"end"`
}

func (m *IPRange) Reset()                    { *m = IPRange{} }
func (*IPRange) ProtoMessage()               {}
func (*IPRange) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{25} }

func (m *IPRange) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *IPRange) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

type PortRange struct {
	Start uint32 `protobuf:"varint,1,opt,name=Start,proto3" json:"start"`
	End   uint32 `protobuf:"varint,2,opt,name=End,proto3" json:"end"`
}

func (m *PortRange) Reset()                    { *m = PortRange{} }
func (*PortRange) ProtoMessage()               {}
func (*PortRange) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{26} }

func (m *PortRange) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *PortRange) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type ICMPControl struct {
	Type uint32 `protobuf:"varint,1,opt,name=Type,proto3" json:"type"`
	Code uint32 `protobuf:"varint,2,opt,name=Code,proto3" json:"type"`
}

func (m *ICMPControl) Reset()                    { *m = ICMPControl{} }
func (*ICMPControl) ProtoMessage()               {}
func (*ICMPControl) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{27} }

func (m *ICMPControl) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ICMPControl) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type NetOutRuleRequest struct {
	// Protocol Protocol `json:"protocol,omitempty"`
	Networks []IPRange `protobuf:"bytes,2,rep,name=Networks" json:"networks"`
	// // a list of ranges of IP addresses to whitelist; Start to End inclusive; default all
	// Networks []IPRange `json:"networks,omitempty"`
	Ports []PortRange `protobuf:"bytes,3,rep,name=Ports" json:"ports"`
	// // a list of ranges of ports to whitelist; Start to End inclusive; ignored if Protocol is ICMP; default all
	// Ports []PortRange `json:"ports,omitempty"`
	// // specifying which ICMP codes to whitelist; ignored if Protocol is not ICMP; default all
	// ICMPs *ICMPControl `json:"icmps,omitempty"`
	ICMPs *ICMPControl `protobuf:"bytes,4,opt,name=ICMPs" json:"icmps"`
	// if true, logging is enabled; ignored if Protocol is not TCP or All; default false
	Log bool `protobuf:"varint,5,opt,name=Log,proto3" json:"log"`
}

func (m *NetOutRuleRequest) Reset()                    { *m = NetOutRuleRequest{} }
func (*NetOutRuleRequest) ProtoMessage()               {}
func (*NetOutRuleRequest) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{28} }

func (m *NetOutRuleRequest) GetNetworks() []IPRange {
	if m != nil {
		return m.Networks
	}
	return nil
}

func (m *NetOutRuleRequest) GetPorts() []PortRange {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *NetOutRuleRequest) GetICMPs() *ICMPControl {
	if m != nil {
		return m.ICMPs
	}
	return nil
}

func (m *NetOutRuleRequest) GetLog() bool {
	if m != nil {
		return m.Log
	}
	return false
}

type BulkNetOutRuleRequest struct {
	NetOutRules []*NetOutRuleRequest `protobuf:"bytes,1,rep,name=NetOutRules" json:"NetOutRules,omitempty"`
}

func (m *BulkNetOutRuleRequest) Reset()                    { *m = BulkNetOutRuleRequest{} }
func (*BulkNetOutRuleRequest) ProtoMessage()               {}
func (*BulkNetOutRuleRequest) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{29} }

func (m *BulkNetOutRuleRequest) GetNetOutRules() []*NetOutRuleRequest {
	if m != nil {
		return m.NetOutRules
	}
	return nil
}

func init() {
	proto.RegisterType((*ProcessSpec)(nil), "vcontainermodels.ProcessSpec")
	proto.RegisterType((*RunResponse)(nil), "vcontainermodels.RunResponse")
	proto.RegisterType((*TTYSpec)(nil), "vcontainermodels.TTYSpec")
	proto.RegisterType((*WindowSize)(nil), "vcontainermodels.WindowSize")
	proto.RegisterType((*ResourceLimits)(nil), "vcontainermodels.ResourceLimits")
	proto.RegisterType((*BandwidthLimits)(nil), "vcontainermodels.BandwidthLimits")
	proto.RegisterType((*ProcessLimits)(nil), "vcontainermodels.ProcessLimits")
	proto.RegisterType((*DiskLimits)(nil), "vcontainermodels.DiskLimits")
	proto.RegisterType((*MemoryLimits)(nil), "vcontainermodels.MemoryLimits")
	proto.RegisterType((*CPULimits)(nil), "vcontainermodels.CPULimits")
	proto.RegisterType((*PidLimits)(nil), "vcontainermodels.PidLimits")
	proto.RegisterType((*PortMapping)(nil), "vcontainermodels.PortMapping")
	proto.RegisterType((*StreamInSpec)(nil), "vcontainermodels.StreamInSpec")
	proto.RegisterType((*StreamInResponse)(nil), "vcontainermodels.StreamInResponse")
	proto.RegisterType((*StreamOutSpec)(nil), "vcontainermodels.StreamOutSpec")
	proto.RegisterType((*StreamOutResponse)(nil), "vcontainermodels.StreamOutResponse")
	proto.RegisterType((*ContainerInfo)(nil), "vcontainermodels.ContainerInfo")
	proto.RegisterType((*Metrics)(nil), "vcontainermodels.Metrics")
	proto.RegisterType((*ContainerMemoryStat)(nil), "vcontainermodels.ContainerMemoryStat")
	proto.RegisterType((*ContainerCPUStat)(nil), "vcontainermodels.ContainerCPUStat")
	proto.RegisterType((*ContainerDiskStat)(nil), "vcontainermodels.ContainerDiskStat")
	proto.RegisterType((*ContainerNetworkStat)(nil), "vcontainermodels.ContainerNetworkStat")
	proto.RegisterType((*StopMessage)(nil), "vcontainermodels.StopMessage")
	proto.RegisterType((*NetInRequest)(nil), "vcontainermodels.NetInRequest")
	proto.RegisterType((*NetInResponse)(nil), "vcontainermodels.NetInResponse")
	proto.RegisterType((*IPRange)(nil), "vcontainermodels.IPRange")
	proto.RegisterType((*PortRange)(nil), "vcontainermodels.PortRange")
	proto.RegisterType((*ICMPControl)(nil), "vcontainermodels.ICMPControl")
	proto.RegisterType((*NetOutRuleRequest)(nil), "vcontainermodels.NetOutRuleRequest")
	proto.RegisterType((*BulkNetOutRuleRequest)(nil), "vcontainermodels.BulkNetOutRuleRequest")
	proto.RegisterEnum("vcontainermodels.DiskLimitScope", DiskLimitScope_name, DiskLimitScope_value)
}
func (x DiskLimitScope) String() string {
	s, ok := DiskLimitScope_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ProcessSpec) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProcessSpec)
	if !ok {
		that2, ok := that.(ProcessSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if len(this.Env) != len(that1.Env) {
		return false
	}
	for i := range this.Env {
		if this.Env[i] != that1.Env[i] {
			return false
		}
	}
	if this.Dir != that1.Dir {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if !this.Limits.Equal(&that1.Limits) {
		return false
	}
	if !this.OverrideContainerLimits.Equal(&that1.OverrideContainerLimits) {
		return false
	}
	if !this.TTY.Equal(&that1.TTY) {
		return false
	}
	if !this.Image.Equal(&that1.Image) {
		return false
	}
	if len(this.BindMounts) != len(that1.BindMounts) {
		return false
	}
	for i := range this.BindMounts {
		if !this.BindMounts[i].Equal(&that1.BindMounts[i]) {
			return false
		}
	}
	return true
}
func (this *RunResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RunResponse)
	if !ok {
		that2, ok := that.(RunResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.ProcessId != that1.ProcessId {
		return false
	}
	return true
}
func (this *TTYSpec) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TTYSpec)
	if !ok {
		that2, ok := that.(TTYSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.WindowSize.Equal(&that1.WindowSize) {
		return false
	}
	return true
}
func (this *WindowSize) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WindowSize)
	if !ok {
		that2, ok := that.(WindowSize)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Columns != that1.Columns {
		return false
	}
	if this.Rows != that1.Rows {
		return false
	}
	return true
}
func (this *ResourceLimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceLimits)
	if !ok {
		that2, ok := that.(ResourceLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.As.Equal(that1.As) {
		return false
	}
	return true
}
func (this *BandwidthLimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BandwidthLimits)
	if !ok {
		that2, ok := that.(BandwidthLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.RateInBytesPerSecond != that1.RateInBytesPerSecond {
		return false
	}
	if this.BurstRateInBytesPerSecond != that1.BurstRateInBytesPerSecond {
		return false
	}
	return true
}
func (this *ProcessLimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProcessLimits)
	if !ok {
		that2, ok := that.(ProcessLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CPU.Equal(&that1.CPU) {
		return false
	}
	if !this.Memory.Equal(&that1.Memory) {
		return false
	}
	return true
}
func (this *DiskLimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DiskLimits)
	if !ok {
		that2, ok := that.(DiskLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.InodeSoft != that1.InodeSoft {
		return false
	}
	if this.InodeHard != that1.InodeHard {
		return false
	}
	if this.ByteSoft != that1.ByteSoft {
		return false
	}
	if this.ByteHard != that1.ByteHard {
		return false
	}
	if this.Scope != that1.Scope {
		return false
	}
	return true
}
func (this *MemoryLimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MemoryLimits)
	if !ok {
		that2, ok := that.(MemoryLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LimitInBytes != that1.LimitInBytes {
		return false
	}
	return true
}
func (this *CPULimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CPULimits)
	if !ok {
		that2, ok := that.(CPULimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LimitInShares != that1.LimitInShares {
		return false
	}
	return true
}
func (this *PidLimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PidLimits)
	if !ok {
		that2, ok := that.(PidLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Max != that1.Max {
		return false
	}
	return true
}
func (this *PortMapping) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PortMapping)
	if !ok {
		that2, ok := that.(PortMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	return true
}
func (this *StreamInSpec) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StreamInSpec)
	if !ok {
		that2, ok := that.(StreamInSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Part == nil {
		if this.Part != nil {
			return false
		}
	} else if this.Part == nil {
		return false
	} else if !this.Part.Equal(that1.Part) {
		return false
	}
	return true
}
func (this *StreamInSpec_Path) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StreamInSpec_Path)
	if !ok {
		that2, ok := that.(StreamInSpec_Path)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *StreamInSpec_User) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StreamInSpec_User)
	if !ok {
		that2, ok := that.(StreamInSpec_User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *StreamInSpec_Content) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StreamInSpec_Content)
	if !ok {
		that2, ok := that.(StreamInSpec_Content)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return false
	}
	return true
}
func (this *StreamInResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StreamInResponse)
	if !ok {
		that2, ok := that.(StreamInResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *StreamOutSpec) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StreamOutSpec)
	if !ok {
		that2, ok := that.(StreamOutSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *StreamOutResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StreamOutResponse)
	if !ok {
		that2, ok := that.(StreamOutResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return false
	}
	return true
}
func (this *ContainerInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerInfo)
	if !ok {
		that2, ok := that.(ContainerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if this.Events[i] != that1.Events[i] {
			return false
		}
	}
	if this.HostIP != that1.HostIP {
		return false
	}
	if this.ContainerIP != that1.ContainerIP {
		return false
	}
	if this.ExternalIP != that1.ExternalIP {
		return false
	}
	if this.ContainerPath != that1.ContainerPath {
		return false
	}
	if len(this.ProcessIDs) != len(that1.ProcessIDs) {
		return false
	}
	for i := range this.ProcessIDs {
		if this.ProcessIDs[i] != that1.ProcessIDs[i] {
			return false
		}
	}
	if !this.Properties.Equal(that1.Properties) {
		return false
	}
	if len(this.MappedPorts) != len(that1.MappedPorts) {
		return false
	}
	for i := range this.MappedPorts {
		if !this.MappedPorts[i].Equal(&that1.MappedPorts[i]) {
			return false
		}
	}
	return true
}
func (this *Metrics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Metrics)
	if !ok {
		that2, ok := that.(Metrics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.MemoryStat.Equal(that1.MemoryStat) {
		return false
	}
	if !this.CPUStat.Equal(that1.CPUStat) {
		return false
	}
	if !this.DiskStat.Equal(that1.DiskStat) {
		return false
	}
	if !this.NetworkStat.Equal(that1.NetworkStat) {
		return false
	}
	return true
}
func (this *ContainerMemoryStat) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerMemoryStat)
	if !ok {
		that2, ok := that.(ContainerMemoryStat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ActiveAnon != that1.ActiveAnon {
		return false
	}
	if this.ActiveFile != that1.ActiveFile {
		return false
	}
	if this.Cache != that1.Cache {
		return false
	}
	if this.HierarchicalMemoryLimit != that1.HierarchicalMemoryLimit {
		return false
	}
	if this.InactiveAnon != that1.InactiveAnon {
		return false
	}
	if this.InactiveFile != that1.InactiveFile {
		return false
	}
	if this.MappedFile != that1.MappedFile {
		return false
	}
	if this.Pgfault != that1.Pgfault {
		return false
	}
	if this.Pgmajfault != that1.Pgmajfault {
		return false
	}
	if this.Pgpgin != that1.Pgpgin {
		return false
	}
	if this.Pgpgout != that1.Pgpgout {
		return false
	}
	if this.Rss != that1.Rss {
		return false
	}
	if this.TotalActiveAnon != that1.TotalActiveAnon {
		return false
	}
	if this.TotalActiveFile != that1.TotalActiveFile {
		return false
	}
	if this.TotalCache != that1.TotalCache {
		return false
	}
	if this.TotalInactiveAnon != that1.TotalInactiveAnon {
		return false
	}
	if this.TotalInactiveFile != that1.TotalInactiveFile {
		return false
	}
	if this.TotalMappedFile != that1.TotalMappedFile {
		return false
	}
	if this.TotalPgfault != that1.TotalPgfault {
		return false
	}
	if this.TotalPgmajfault != that1.TotalPgmajfault {
		return false
	}
	if this.TotalPgpgin != that1.TotalPgpgin {
		return false
	}
	if this.TotalPgpgout != that1.TotalPgpgout {
		return false
	}
	if this.TotalRss != that1.TotalRss {
		return false
	}
	if this.TotalUnevictable != that1.TotalUnevictable {
		return false
	}
	if this.Unevictable != that1.Unevictable {
		return false
	}
	if this.Swap != that1.Swap {
		return false
	}
	if this.HierarchicalMemswLimit != that1.HierarchicalMemswLimit {
		return false
	}
	if this.TotalSwap != that1.TotalSwap {
		return false
	}
	if this.TotalUsageTowardLimit != that1.TotalUsageTowardLimit {
		return false
	}
	return true
}
func (this *ContainerCPUStat) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerCPUStat)
	if !ok {
		that2, ok := that.(ContainerCPUStat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Usage != that1.Usage {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.System != that1.System {
		return false
	}
	return true
}
func (this *ContainerDiskStat) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerDiskStat)
	if !ok {
		that2, ok := that.(ContainerDiskStat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.TotalBytesUsed != that1.TotalBytesUsed {
		return false
	}
	if this.TotalInodesUsed != that1.TotalInodesUsed {
		return false
	}
	if this.ExclusiveBytesUsed != that1.ExclusiveBytesUsed {
		return false
	}
	if this.ExclusiveInodesUsed != that1.ExclusiveInodesUsed {
		return false
	}
	return true
}
func (this *ContainerNetworkStat) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerNetworkStat)
	if !ok {
		that2, ok := that.(ContainerNetworkStat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.RxBytes != that1.RxBytes {
		return false
	}
	if this.TxBytes != that1.TxBytes {
		return false
	}
	return true
}
func (this *StopMessage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StopMessage)
	if !ok {
		that2, ok := that.(StopMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Kill != that1.Kill {
		return false
	}
	return true
}
func (this *NetInRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NetInRequest)
	if !ok {
		that2, ok := that.(NetInRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	return true
}
func (this *NetInResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NetInResponse)
	if !ok {
		that2, ok := that.(NetInResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	return true
}
func (this *IPRange) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*IPRange)
	if !ok {
		that2, ok := that.(IPRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Start, that1.Start) {
		return false
	}
	if !bytes.Equal(this.End, that1.End) {
		return false
	}
	return true
}
func (this *PortRange) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PortRange)
	if !ok {
		that2, ok := that.(PortRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *ICMPControl) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ICMPControl)
	if !ok {
		that2, ok := that.(ICMPControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	return true
}
func (this *NetOutRuleRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NetOutRuleRequest)
	if !ok {
		that2, ok := that.(NetOutRuleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Networks) != len(that1.Networks) {
		return false
	}
	for i := range this.Networks {
		if !this.Networks[i].Equal(&that1.Networks[i]) {
			return false
		}
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(&that1.Ports[i]) {
			return false
		}
	}
	if !this.ICMPs.Equal(that1.ICMPs) {
		return false
	}
	if this.Log != that1.Log {
		return false
	}
	return true
}
func (this *BulkNetOutRuleRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BulkNetOutRuleRequest)
	if !ok {
		that2, ok := that.(BulkNetOutRuleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.NetOutRules) != len(that1.NetOutRules) {
		return false
	}
	for i := range this.NetOutRules {
		if !this.NetOutRules[i].Equal(that1.NetOutRules[i]) {
			return false
		}
	}
	return true
}
func (this *ProcessSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&vcontainermodels.ProcessSpec{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "Dir: "+fmt.Sprintf("%#v", this.Dir)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "Limits: "+strings.Replace(this.Limits.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "OverrideContainerLimits: "+strings.Replace(this.OverrideContainerLimits.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "TTY: "+strings.Replace(this.TTY.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Image: "+strings.Replace(this.Image.GoString(), `&`, ``, 1)+",\n")
	if this.BindMounts != nil {
		s = append(s, "BindMounts: "+fmt.Sprintf("%#v", this.BindMounts)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RunResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.RunResponse{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "ProcessId: "+fmt.Sprintf("%#v", this.ProcessId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TTYSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.TTYSpec{")
	s = append(s, "WindowSize: "+strings.Replace(this.WindowSize.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WindowSize) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.WindowSize{")
	s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	s = append(s, "Rows: "+fmt.Sprintf("%#v", this.Rows)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.ResourceLimits{")
	if this.As != nil {
		s = append(s, "As: "+fmt.Sprintf("%#v", this.As)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BandwidthLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.BandwidthLimits{")
	s = append(s, "RateInBytesPerSecond: "+fmt.Sprintf("%#v", this.RateInBytesPerSecond)+",\n")
	s = append(s, "BurstRateInBytesPerSecond: "+fmt.Sprintf("%#v", this.BurstRateInBytesPerSecond)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProcessLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.ProcessLimits{")
	s = append(s, "CPU: "+strings.Replace(this.CPU.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Memory: "+strings.Replace(this.Memory.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiskLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&vcontainermodels.DiskLimits{")
	s = append(s, "InodeSoft: "+fmt.Sprintf("%#v", this.InodeSoft)+",\n")
	s = append(s, "InodeHard: "+fmt.Sprintf("%#v", this.InodeHard)+",\n")
	s = append(s, "ByteSoft: "+fmt.Sprintf("%#v", this.ByteSoft)+",\n")
	s = append(s, "ByteHard: "+fmt.Sprintf("%#v", this.ByteHard)+",\n")
	s = append(s, "Scope: "+fmt.Sprintf("%#v", this.Scope)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MemoryLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.MemoryLimits{")
	s = append(s, "LimitInBytes: "+fmt.Sprintf("%#v", this.LimitInBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPULimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.CPULimits{")
	s = append(s, "LimitInShares: "+fmt.Sprintf("%#v", this.LimitInShares)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PidLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.PidLimits{")
	s = append(s, "Max: "+fmt.Sprintf("%#v", this.Max)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.PortMapping{")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamInSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&vcontainermodels.StreamInSpec{")
	if this.Part != nil {
		s = append(s, "Part: "+fmt.Sprintf("%#v", this.Part)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamInSpec_Path) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&vcontainermodels.StreamInSpec_Path{` +
		`Path:` + fmt.Sprintf("%#v", this.Path) + `}`}, ", ")
	return s
}
func (this *StreamInSpec_User) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&vcontainermodels.StreamInSpec_User{` +
		`User:` + fmt.Sprintf("%#v", this.User) + `}`}, ", ")
	return s
}
func (this *StreamInSpec_Content) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&vcontainermodels.StreamInSpec_Content{` +
		`Content:` + fmt.Sprintf("%#v", this.Content) + `}`}, ", ")
	return s
}
func (this *StreamInResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.StreamInResponse{")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamOutSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.StreamOutSpec{")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamOutResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.StreamOutResponse{")
	s = append(s, "Content: "+fmt.Sprintf("%#v", this.Content)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&vcontainermodels.ContainerInfo{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Events: "+fmt.Sprintf("%#v", this.Events)+",\n")
	s = append(s, "HostIP: "+fmt.Sprintf("%#v", this.HostIP)+",\n")
	s = append(s, "ContainerIP: "+fmt.Sprintf("%#v", this.ContainerIP)+",\n")
	s = append(s, "ExternalIP: "+fmt.Sprintf("%#v", this.ExternalIP)+",\n")
	s = append(s, "ContainerPath: "+fmt.Sprintf("%#v", this.ContainerPath)+",\n")
	s = append(s, "ProcessIDs: "+fmt.Sprintf("%#v", this.ProcessIDs)+",\n")
	if this.Properties != nil {
		s = append(s, "Properties: "+fmt.Sprintf("%#v", this.Properties)+",\n")
	}
	if this.MappedPorts != nil {
		s = append(s, "MappedPorts: "+fmt.Sprintf("%#v", this.MappedPorts)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Metrics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&vcontainermodels.Metrics{")
	if this.MemoryStat != nil {
		s = append(s, "MemoryStat: "+fmt.Sprintf("%#v", this.MemoryStat)+",\n")
	}
	if this.CPUStat != nil {
		s = append(s, "CPUStat: "+fmt.Sprintf("%#v", this.CPUStat)+",\n")
	}
	if this.DiskStat != nil {
		s = append(s, "DiskStat: "+fmt.Sprintf("%#v", this.DiskStat)+",\n")
	}
	if this.NetworkStat != nil {
		s = append(s, "NetworkStat: "+fmt.Sprintf("%#v", this.NetworkStat)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerMemoryStat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 33)
	s = append(s, "&vcontainermodels.ContainerMemoryStat{")
	s = append(s, "ActiveAnon: "+fmt.Sprintf("%#v", this.ActiveAnon)+",\n")
	s = append(s, "ActiveFile: "+fmt.Sprintf("%#v", this.ActiveFile)+",\n")
	s = append(s, "Cache: "+fmt.Sprintf("%#v", this.Cache)+",\n")
	s = append(s, "HierarchicalMemoryLimit: "+fmt.Sprintf("%#v", this.HierarchicalMemoryLimit)+",\n")
	s = append(s, "InactiveAnon: "+fmt.Sprintf("%#v", this.InactiveAnon)+",\n")
	s = append(s, "InactiveFile: "+fmt.Sprintf("%#v", this.InactiveFile)+",\n")
	s = append(s, "MappedFile: "+fmt.Sprintf("%#v", this.MappedFile)+",\n")
	s = append(s, "Pgfault: "+fmt.Sprintf("%#v", this.Pgfault)+",\n")
	s = append(s, "Pgmajfault: "+fmt.Sprintf("%#v", this.Pgmajfault)+",\n")
	s = append(s, "Pgpgin: "+fmt.Sprintf("%#v", this.Pgpgin)+",\n")
	s = append(s, "Pgpgout: "+fmt.Sprintf("%#v", this.Pgpgout)+",\n")
	s = append(s, "Rss: "+fmt.Sprintf("%#v", this.Rss)+",\n")
	s = append(s, "TotalActiveAnon: "+fmt.Sprintf("%#v", this.TotalActiveAnon)+",\n")
	s = append(s, "TotalActiveFile: "+fmt.Sprintf("%#v", this.TotalActiveFile)+",\n")
	s = append(s, "TotalCache: "+fmt.Sprintf("%#v", this.TotalCache)+",\n")
	s = append(s, "TotalInactiveAnon: "+fmt.Sprintf("%#v", this.TotalInactiveAnon)+",\n")
	s = append(s, "TotalInactiveFile: "+fmt.Sprintf("%#v", this.TotalInactiveFile)+",\n")
	s = append(s, "TotalMappedFile: "+fmt.Sprintf("%#v", this.TotalMappedFile)+",\n")
	s = append(s, "TotalPgfault: "+fmt.Sprintf("%#v", this.TotalPgfault)+",\n")
	s = append(s, "TotalPgmajfault: "+fmt.Sprintf("%#v", this.TotalPgmajfault)+",\n")
	s = append(s, "TotalPgpgin: "+fmt.Sprintf("%#v", this.TotalPgpgin)+",\n")
	s = append(s, "TotalPgpgout: "+fmt.Sprintf("%#v", this.TotalPgpgout)+",\n")
	s = append(s, "TotalRss: "+fmt.Sprintf("%#v", this.TotalRss)+",\n")
	s = append(s, "TotalUnevictable: "+fmt.Sprintf("%#v", this.TotalUnevictable)+",\n")
	s = append(s, "Unevictable: "+fmt.Sprintf("%#v", this.Unevictable)+",\n")
	s = append(s, "Swap: "+fmt.Sprintf("%#v", this.Swap)+",\n")
	s = append(s, "HierarchicalMemswLimit: "+fmt.Sprintf("%#v", this.HierarchicalMemswLimit)+",\n")
	s = append(s, "TotalSwap: "+fmt.Sprintf("%#v", this.TotalSwap)+",\n")
	s = append(s, "TotalUsageTowardLimit: "+fmt.Sprintf("%#v", this.TotalUsageTowardLimit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerCPUStat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&vcontainermodels.ContainerCPUStat{")
	s = append(s, "Usage: "+fmt.Sprintf("%#v", this.Usage)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "System: "+fmt.Sprintf("%#v", this.System)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerDiskStat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&vcontainermodels.ContainerDiskStat{")
	s = append(s, "TotalBytesUsed: "+fmt.Sprintf("%#v", this.TotalBytesUsed)+",\n")
	s = append(s, "TotalInodesUsed: "+fmt.Sprintf("%#v", this.TotalInodesUsed)+",\n")
	s = append(s, "ExclusiveBytesUsed: "+fmt.Sprintf("%#v", this.ExclusiveBytesUsed)+",\n")
	s = append(s, "ExclusiveInodesUsed: "+fmt.Sprintf("%#v", this.ExclusiveInodesUsed)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkStat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.ContainerNetworkStat{")
	s = append(s, "RxBytes: "+fmt.Sprintf("%#v", this.RxBytes)+",\n")
	s = append(s, "TxBytes: "+fmt.Sprintf("%#v", this.TxBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StopMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.StopMessage{")
	s = append(s, "Kill: "+fmt.Sprintf("%#v", this.Kill)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetInRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.NetInRequest{")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetInResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.NetInResponse{")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.IPRange{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.PortRange{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ICMPControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&vcontainermodels.ICMPControl{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetOutRuleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&vcontainermodels.NetOutRuleRequest{")
	if this.Networks != nil {
		s = append(s, "Networks: "+fmt.Sprintf("%#v", this.Networks)+",\n")
	}
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	if this.ICMPs != nil {
		s = append(s, "ICMPs: "+fmt.Sprintf("%#v", this.ICMPs)+",\n")
	}
	s = append(s, "Log: "+fmt.Sprintf("%#v", this.Log)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BulkNetOutRuleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.BulkNetOutRuleRequest{")
	if this.NetOutRules != nil {
		s = append(s, "NetOutRules: "+fmt.Sprintf("%#v", this.NetOutRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringContainer(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ProcessSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Dir) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Dir)))
		i += copy(dAtA[i:], m.Dir)
	}
	if len(m.User) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintContainer(dAtA, i, uint64(m.Limits.Size()))
	n1, err := m.Limits.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x42
	i++
	i = encodeVarintContainer(dAtA, i, uint64(m.OverrideContainerLimits.Size()))
	n2, err := m.OverrideContainerLimits.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x4a
	i++
	i = encodeVarintContainer(dAtA, i, uint64(m.TTY.Size()))
	n3, err := m.TTY.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x52
	i++
	i = encodeVarintContainer(dAtA, i, uint64(m.Image.Size()))
	n4, err := m.Image.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.BindMounts) > 0 {
		for _, msg := range m.BindMounts {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RunResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.ProcessId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ProcessId)))
		i += copy(dAtA[i:], m.ProcessId)
	}
	return i, nil
}

func (m *TTYSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TTYSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintContainer(dAtA, i, uint64(m.WindowSize.Size()))
	n5, err := m.WindowSize.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *WindowSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowSize) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Columns != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Columns))
	}
	if m.Rows != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Rows))
	}
	return i, nil
}

func (m *ResourceLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.As != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.As.Size()))
		n6, err := m.As.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *BandwidthLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BandwidthLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RateInBytesPerSecond != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.RateInBytesPerSecond))
	}
	if m.BurstRateInBytesPerSecond != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.BurstRateInBytesPerSecond))
	}
	return i, nil
}

func (m *ProcessLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintContainer(dAtA, i, uint64(m.CPU.Size()))
	n7, err := m.CPU.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x12
	i++
	i = encodeVarintContainer(dAtA, i, uint64(m.Memory.Size()))
	n8, err := m.Memory.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *DiskLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InodeSoft != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.InodeSoft))
	}
	if m.InodeHard != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.InodeHard))
	}
	if m.ByteSoft != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ByteSoft))
	}
	if m.ByteHard != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ByteHard))
	}
	if m.Scope != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Scope))
	}
	return i, nil
}

func (m *MemoryLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LimitInBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.LimitInBytes))
	}
	return i, nil
}

func (m *CPULimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPULimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LimitInShares != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.LimitInShares))
	}
	return i, nil
}

func (m *PidLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PidLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Max != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Max))
	}
	return i, nil
}

func (m *PortMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HostPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.HostPort))
	}
	if m.ContainerPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ContainerPort))
	}
	return i, nil
}

func (m *StreamInSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamInSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Part != nil {
		nn9, err := m.Part.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	return i, nil
}

func (m *StreamInSpec_Path) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintContainer(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	return i, nil
}
func (m *StreamInSpec_User) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintContainer(dAtA, i, uint64(len(m.User)))
	i += copy(dAtA[i:], m.User)
	return i, nil
}
func (m *StreamInSpec_Content) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Content != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}
func (m *StreamInResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamInResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *StreamOutSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamOutSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.User) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *StreamOutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamOutResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *ContainerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Events) > 0 {
		for _, s := range m.Events {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.HostIP) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.HostIP)))
		i += copy(dAtA[i:], m.HostIP)
	}
	if len(m.ContainerIP) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ContainerIP)))
		i += copy(dAtA[i:], m.ContainerIP)
	}
	if len(m.ExternalIP) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ExternalIP)))
		i += copy(dAtA[i:], m.ExternalIP)
	}
	if len(m.ContainerPath) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ContainerPath)))
		i += copy(dAtA[i:], m.ContainerPath)
	}
	if len(m.ProcessIDs) > 0 {
		for _, s := range m.ProcessIDs {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Properties != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Properties.Size()))
		n10, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.MappedPorts) > 0 {
		for _, msg := range m.MappedPorts {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemoryStat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.MemoryStat.Size()))
		n11, err := m.MemoryStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.CPUStat != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.CPUStat.Size()))
		n12, err := m.CPUStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.DiskStat != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.DiskStat.Size()))
		n13, err := m.DiskStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.NetworkStat != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.NetworkStat.Size()))
		n14, err := m.NetworkStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *ContainerMemoryStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerMemoryStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActiveAnon != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ActiveAnon))
	}
	if m.ActiveFile != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ActiveFile))
	}
	if m.Cache != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Cache))
	}
	if m.HierarchicalMemoryLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.HierarchicalMemoryLimit))
	}
	if m.InactiveAnon != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.InactiveAnon))
	}
	if m.InactiveFile != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.InactiveFile))
	}
	if m.MappedFile != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.MappedFile))
	}
	if m.Pgfault != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Pgfault))
	}
	if m.Pgmajfault != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Pgmajfault))
	}
	if m.Pgpgin != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Pgpgin))
	}
	if m.Pgpgout != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Pgpgout))
	}
	if m.Rss != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Rss))
	}
	if m.TotalActiveAnon != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalActiveAnon))
	}
	if m.TotalActiveFile != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalActiveFile))
	}
	if m.TotalCache != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalCache))
	}
	if m.TotalInactiveAnon != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalInactiveAnon))
	}
	if m.TotalInactiveFile != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalInactiveFile))
	}
	if m.TotalMappedFile != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalMappedFile))
	}
	if m.TotalPgfault != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalPgfault))
	}
	if m.TotalPgmajfault != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalPgmajfault))
	}
	if m.TotalPgpgin != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalPgpgin))
	}
	if m.TotalPgpgout != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalPgpgout))
	}
	if m.TotalRss != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalRss))
	}
	if m.TotalUnevictable != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalUnevictable))
	}
	if m.Unevictable != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Unevictable))
	}
	if m.Swap != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Swap))
	}
	if m.HierarchicalMemswLimit != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.HierarchicalMemswLimit))
	}
	if m.TotalSwap != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalSwap))
	}
	if m.TotalUsageTowardLimit != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalUsageTowardLimit))
	}
	return i, nil
}

func (m *ContainerCPUStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerCPUStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Usage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Usage))
	}
	if m.User != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.User))
	}
	if m.System != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.System))
	}
	return i, nil
}

func (m *ContainerDiskStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerDiskStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalBytesUsed != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalBytesUsed))
	}
	if m.TotalInodesUsed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TotalInodesUsed))
	}
	if m.ExclusiveBytesUsed != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ExclusiveBytesUsed))
	}
	if m.ExclusiveInodesUsed != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ExclusiveInodesUsed))
	}
	return i, nil
}

func (m *ContainerNetworkStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RxBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.RxBytes))
	}
	if m.TxBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TxBytes))
	}
	return i, nil
}

func (m *StopMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kill {
		dAtA[i] = 0x8
		i++
		if m.Kill {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NetInRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetInRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HostPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.HostPort))
	}
	if m.ContainerPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ContainerPort))
	}
	return i, nil
}

func (m *NetInResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetInResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HostPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.HostPort))
	}
	if m.ContainerPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ContainerPort))
	}
	return i, nil
}

func (m *IPRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	return i, nil
}

func (m *PortRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *ICMPControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Type))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *NetOutRuleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetOutRuleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Networks) > 0 {
		for _, msg := range m.Networks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ICMPs != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ICMPs.Size()))
		n15, err := m.ICMPs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Log {
		dAtA[i] = 0x28
		i++
		if m.Log {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BulkNetOutRuleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkNetOutRuleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NetOutRules) > 0 {
		for _, msg := range m.NetOutRules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Container(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Container(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintContainer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ProcessSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	l = len(m.Dir)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = m.Limits.Size()
	n += 1 + l + sovContainer(uint64(l))
	l = m.OverrideContainerLimits.Size()
	n += 1 + l + sovContainer(uint64(l))
	l = m.TTY.Size()
	n += 1 + l + sovContainer(uint64(l))
	l = m.Image.Size()
	n += 1 + l + sovContainer(uint64(l))
	if len(m.BindMounts) > 0 {
		for _, e := range m.BindMounts {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	return n
}

func (m *RunResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.ProcessId)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *TTYSpec) Size() (n int) {
	var l int
	_ = l
	l = m.WindowSize.Size()
	n += 1 + l + sovContainer(uint64(l))
	return n
}

func (m *WindowSize) Size() (n int) {
	var l int
	_ = l
	if m.Columns != 0 {
		n += 1 + sovContainer(uint64(m.Columns))
	}
	if m.Rows != 0 {
		n += 1 + sovContainer(uint64(m.Rows))
	}
	return n
}

func (m *ResourceLimits) Size() (n int) {
	var l int
	_ = l
	if m.As != nil {
		l = m.As.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *BandwidthLimits) Size() (n int) {
	var l int
	_ = l
	if m.RateInBytesPerSecond != 0 {
		n += 1 + sovContainer(uint64(m.RateInBytesPerSecond))
	}
	if m.BurstRateInBytesPerSecond != 0 {
		n += 1 + sovContainer(uint64(m.BurstRateInBytesPerSecond))
	}
	return n
}

func (m *ProcessLimits) Size() (n int) {
	var l int
	_ = l
	l = m.CPU.Size()
	n += 1 + l + sovContainer(uint64(l))
	l = m.Memory.Size()
	n += 1 + l + sovContainer(uint64(l))
	return n
}

func (m *DiskLimits) Size() (n int) {
	var l int
	_ = l
	if m.InodeSoft != 0 {
		n += 1 + sovContainer(uint64(m.InodeSoft))
	}
	if m.InodeHard != 0 {
		n += 1 + sovContainer(uint64(m.InodeHard))
	}
	if m.ByteSoft != 0 {
		n += 1 + sovContainer(uint64(m.ByteSoft))
	}
	if m.ByteHard != 0 {
		n += 1 + sovContainer(uint64(m.ByteHard))
	}
	if m.Scope != 0 {
		n += 1 + sovContainer(uint64(m.Scope))
	}
	return n
}

func (m *MemoryLimits) Size() (n int) {
	var l int
	_ = l
	if m.LimitInBytes != 0 {
		n += 1 + sovContainer(uint64(m.LimitInBytes))
	}
	return n
}

func (m *CPULimits) Size() (n int) {
	var l int
	_ = l
	if m.LimitInShares != 0 {
		n += 1 + sovContainer(uint64(m.LimitInShares))
	}
	return n
}

func (m *PidLimits) Size() (n int) {
	var l int
	_ = l
	if m.Max != 0 {
		n += 1 + sovContainer(uint64(m.Max))
	}
	return n
}

func (m *PortMapping) Size() (n int) {
	var l int
	_ = l
	if m.HostPort != 0 {
		n += 1 + sovContainer(uint64(m.HostPort))
	}
	if m.ContainerPort != 0 {
		n += 1 + sovContainer(uint64(m.ContainerPort))
	}
	return n
}

func (m *StreamInSpec) Size() (n int) {
	var l int
	_ = l
	if m.Part != nil {
		n += m.Part.Size()
	}
	return n
}

func (m *StreamInSpec_Path) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovContainer(uint64(l))
	return n
}
func (m *StreamInSpec_User) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	n += 1 + l + sovContainer(uint64(l))
	return n
}
func (m *StreamInSpec_Content) Size() (n int) {
	var l int
	_ = l
	if m.Content != nil {
		l = len(m.Content)
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}
func (m *StreamInResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *StreamOutSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *StreamOutResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *ContainerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, s := range m.Events {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	l = len(m.HostIP)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.ContainerIP)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.ExternalIP)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.ContainerPath)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if len(m.ProcessIDs) > 0 {
		for _, s := range m.ProcessIDs {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	if len(m.MappedPorts) > 0 {
		for _, e := range m.MappedPorts {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	return n
}

func (m *Metrics) Size() (n int) {
	var l int
	_ = l
	if m.MemoryStat != nil {
		l = m.MemoryStat.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.CPUStat != nil {
		l = m.CPUStat.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.DiskStat != nil {
		l = m.DiskStat.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.NetworkStat != nil {
		l = m.NetworkStat.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *ContainerMemoryStat) Size() (n int) {
	var l int
	_ = l
	if m.ActiveAnon != 0 {
		n += 1 + sovContainer(uint64(m.ActiveAnon))
	}
	if m.ActiveFile != 0 {
		n += 1 + sovContainer(uint64(m.ActiveFile))
	}
	if m.Cache != 0 {
		n += 1 + sovContainer(uint64(m.Cache))
	}
	if m.HierarchicalMemoryLimit != 0 {
		n += 1 + sovContainer(uint64(m.HierarchicalMemoryLimit))
	}
	if m.InactiveAnon != 0 {
		n += 1 + sovContainer(uint64(m.InactiveAnon))
	}
	if m.InactiveFile != 0 {
		n += 1 + sovContainer(uint64(m.InactiveFile))
	}
	if m.MappedFile != 0 {
		n += 1 + sovContainer(uint64(m.MappedFile))
	}
	if m.Pgfault != 0 {
		n += 1 + sovContainer(uint64(m.Pgfault))
	}
	if m.Pgmajfault != 0 {
		n += 1 + sovContainer(uint64(m.Pgmajfault))
	}
	if m.Pgpgin != 0 {
		n += 1 + sovContainer(uint64(m.Pgpgin))
	}
	if m.Pgpgout != 0 {
		n += 1 + sovContainer(uint64(m.Pgpgout))
	}
	if m.Rss != 0 {
		n += 1 + sovContainer(uint64(m.Rss))
	}
	if m.TotalActiveAnon != 0 {
		n += 1 + sovContainer(uint64(m.TotalActiveAnon))
	}
	if m.TotalActiveFile != 0 {
		n += 1 + sovContainer(uint64(m.TotalActiveFile))
	}
	if m.TotalCache != 0 {
		n += 1 + sovContainer(uint64(m.TotalCache))
	}
	if m.TotalInactiveAnon != 0 {
		n += 2 + sovContainer(uint64(m.TotalInactiveAnon))
	}
	if m.TotalInactiveFile != 0 {
		n += 2 + sovContainer(uint64(m.TotalInactiveFile))
	}
	if m.TotalMappedFile != 0 {
		n += 2 + sovContainer(uint64(m.TotalMappedFile))
	}
	if m.TotalPgfault != 0 {
		n += 2 + sovContainer(uint64(m.TotalPgfault))
	}
	if m.TotalPgmajfault != 0 {
		n += 2 + sovContainer(uint64(m.TotalPgmajfault))
	}
	if m.TotalPgpgin != 0 {
		n += 2 + sovContainer(uint64(m.TotalPgpgin))
	}
	if m.TotalPgpgout != 0 {
		n += 2 + sovContainer(uint64(m.TotalPgpgout))
	}
	if m.TotalRss != 0 {
		n += 2 + sovContainer(uint64(m.TotalRss))
	}
	if m.TotalUnevictable != 0 {
		n += 2 + sovContainer(uint64(m.TotalUnevictable))
	}
	if m.Unevictable != 0 {
		n += 2 + sovContainer(uint64(m.Unevictable))
	}
	if m.Swap != 0 {
		n += 2 + sovContainer(uint64(m.Swap))
	}
	if m.HierarchicalMemswLimit != 0 {
		n += 2 + sovContainer(uint64(m.HierarchicalMemswLimit))
	}
	if m.TotalSwap != 0 {
		n += 2 + sovContainer(uint64(m.TotalSwap))
	}
	if m.TotalUsageTowardLimit != 0 {
		n += 2 + sovContainer(uint64(m.TotalUsageTowardLimit))
	}
	return n
}

func (m *ContainerCPUStat) Size() (n int) {
	var l int
	_ = l
	if m.Usage != 0 {
		n += 1 + sovContainer(uint64(m.Usage))
	}
	if m.User != 0 {
		n += 1 + sovContainer(uint64(m.User))
	}
	if m.System != 0 {
		n += 1 + sovContainer(uint64(m.System))
	}
	return n
}

func (m *ContainerDiskStat) Size() (n int) {
	var l int
	_ = l
	if m.TotalBytesUsed != 0 {
		n += 1 + sovContainer(uint64(m.TotalBytesUsed))
	}
	if m.TotalInodesUsed != 0 {
		n += 1 + sovContainer(uint64(m.TotalInodesUsed))
	}
	if m.ExclusiveBytesUsed != 0 {
		n += 1 + sovContainer(uint64(m.ExclusiveBytesUsed))
	}
	if m.ExclusiveInodesUsed != 0 {
		n += 1 + sovContainer(uint64(m.ExclusiveInodesUsed))
	}
	return n
}

func (m *ContainerNetworkStat) Size() (n int) {
	var l int
	_ = l
	if m.RxBytes != 0 {
		n += 1 + sovContainer(uint64(m.RxBytes))
	}
	if m.TxBytes != 0 {
		n += 1 + sovContainer(uint64(m.TxBytes))
	}
	return n
}

func (m *StopMessage) Size() (n int) {
	var l int
	_ = l
	if m.Kill {
		n += 2
	}
	return n
}

func (m *NetInRequest) Size() (n int) {
	var l int
	_ = l
	if m.HostPort != 0 {
		n += 1 + sovContainer(uint64(m.HostPort))
	}
	if m.ContainerPort != 0 {
		n += 1 + sovContainer(uint64(m.ContainerPort))
	}
	return n
}

func (m *NetInResponse) Size() (n int) {
	var l int
	_ = l
	if m.HostPort != 0 {
		n += 1 + sovContainer(uint64(m.HostPort))
	}
	if m.ContainerPort != 0 {
		n += 1 + sovContainer(uint64(m.ContainerPort))
	}
	return n
}

func (m *IPRange) Size() (n int) {
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *PortRange) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovContainer(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovContainer(uint64(m.End))
	}
	return n
}

func (m *ICMPControl) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovContainer(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovContainer(uint64(m.Code))
	}
	return n
}

func (m *NetOutRuleRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Networks) > 0 {
		for _, e := range m.Networks {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if m.ICMPs != nil {
		l = m.ICMPs.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.Log {
		n += 2
	}
	return n
}

func (m *BulkNetOutRuleRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.NetOutRules) > 0 {
		for _, e := range m.NetOutRules {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	return n
}

func sovContainer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozContainer(x uint64) (n int) {
	return sovContainer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ProcessSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProcessSpec{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Args:` + fmt.Sprintf("%v", this.Args) + `,`,
		`Env:` + fmt.Sprintf("%v", this.Env) + `,`,
		`Dir:` + fmt.Sprintf("%v", this.Dir) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`Limits:` + strings.Replace(strings.Replace(this.Limits.String(), "ResourceLimits", "ResourceLimits", 1), `&`, ``, 1) + `,`,
		`OverrideContainerLimits:` + strings.Replace(strings.Replace(this.OverrideContainerLimits.String(), "ProcessLimits", "ProcessLimits", 1), `&`, ``, 1) + `,`,
		`TTY:` + strings.Replace(strings.Replace(this.TTY.String(), "TTYSpec", "TTYSpec", 1), `&`, ``, 1) + `,`,
		`Image:` + strings.Replace(strings.Replace(this.Image.String(), "ImageRef", "ImageRef", 1), `&`, ``, 1) + `,`,
		`BindMounts:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.BindMounts), "BindMount", "BindMount", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RunResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RunResponse{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`ProcessId:` + fmt.Sprintf("%v", this.ProcessId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TTYSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TTYSpec{`,
		`WindowSize:` + strings.Replace(strings.Replace(this.WindowSize.String(), "WindowSize", "WindowSize", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WindowSize) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WindowSize{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceLimits{`,
		`As:` + strings.Replace(fmt.Sprintf("%v", this.As), "UInt64Value", "google_protobuf1.UInt64Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BandwidthLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BandwidthLimits{`,
		`RateInBytesPerSecond:` + fmt.Sprintf("%v", this.RateInBytesPerSecond) + `,`,
		`BurstRateInBytesPerSecond:` + fmt.Sprintf("%v", this.BurstRateInBytesPerSecond) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProcessLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProcessLimits{`,
		`CPU:` + strings.Replace(strings.Replace(this.CPU.String(), "CPULimits", "CPULimits", 1), `&`, ``, 1) + `,`,
		`Memory:` + strings.Replace(strings.Replace(this.Memory.String(), "MemoryLimits", "MemoryLimits", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiskLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiskLimits{`,
		`InodeSoft:` + fmt.Sprintf("%v", this.InodeSoft) + `,`,
		`InodeHard:` + fmt.Sprintf("%v", this.InodeHard) + `,`,
		`ByteSoft:` + fmt.Sprintf("%v", this.ByteSoft) + `,`,
		`ByteHard:` + fmt.Sprintf("%v", this.ByteHard) + `,`,
		`Scope:` + fmt.Sprintf("%v", this.Scope) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MemoryLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MemoryLimits{`,
		`LimitInBytes:` + fmt.Sprintf("%v", this.LimitInBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPULimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPULimits{`,
		`LimitInShares:` + fmt.Sprintf("%v", this.LimitInShares) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PidLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PidLimits{`,
		`Max:` + fmt.Sprintf("%v", this.Max) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortMapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortMapping{`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamInSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamInSpec{`,
		`Part:` + fmt.Sprintf("%v", this.Part) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamInSpec_Path) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamInSpec_Path{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamInSpec_User) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamInSpec_User{`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamInSpec_Content) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamInSpec_Content{`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamInResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamInResponse{`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamOutSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamOutSpec{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamOutResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamOutResponse{`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerInfo{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Events:` + fmt.Sprintf("%v", this.Events) + `,`,
		`HostIP:` + fmt.Sprintf("%v", this.HostIP) + `,`,
		`ContainerIP:` + fmt.Sprintf("%v", this.ContainerIP) + `,`,
		`ExternalIP:` + fmt.Sprintf("%v", this.ExternalIP) + `,`,
		`ContainerPath:` + fmt.Sprintf("%v", this.ContainerPath) + `,`,
		`ProcessIDs:` + fmt.Sprintf("%v", this.ProcessIDs) + `,`,
		`Properties:` + strings.Replace(fmt.Sprintf("%v", this.Properties), "Properties", "Properties", 1) + `,`,
		`MappedPorts:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.MappedPorts), "PortMapping", "PortMapping", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Metrics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Metrics{`,
		`MemoryStat:` + strings.Replace(fmt.Sprintf("%v", this.MemoryStat), "ContainerMemoryStat", "ContainerMemoryStat", 1) + `,`,
		`CPUStat:` + strings.Replace(fmt.Sprintf("%v", this.CPUStat), "ContainerCPUStat", "ContainerCPUStat", 1) + `,`,
		`DiskStat:` + strings.Replace(fmt.Sprintf("%v", this.DiskStat), "ContainerDiskStat", "ContainerDiskStat", 1) + `,`,
		`NetworkStat:` + strings.Replace(fmt.Sprintf("%v", this.NetworkStat), "ContainerNetworkStat", "ContainerNetworkStat", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerMemoryStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerMemoryStat{`,
		`ActiveAnon:` + fmt.Sprintf("%v", this.ActiveAnon) + `,`,
		`ActiveFile:` + fmt.Sprintf("%v", this.ActiveFile) + `,`,
		`Cache:` + fmt.Sprintf("%v", this.Cache) + `,`,
		`HierarchicalMemoryLimit:` + fmt.Sprintf("%v", this.HierarchicalMemoryLimit) + `,`,
		`InactiveAnon:` + fmt.Sprintf("%v", this.InactiveAnon) + `,`,
		`InactiveFile:` + fmt.Sprintf("%v", this.InactiveFile) + `,`,
		`MappedFile:` + fmt.Sprintf("%v", this.MappedFile) + `,`,
		`Pgfault:` + fmt.Sprintf("%v", this.Pgfault) + `,`,
		`Pgmajfault:` + fmt.Sprintf("%v", this.Pgmajfault) + `,`,
		`Pgpgin:` + fmt.Sprintf("%v", this.Pgpgin) + `,`,
		`Pgpgout:` + fmt.Sprintf("%v", this.Pgpgout) + `,`,
		`Rss:` + fmt.Sprintf("%v", this.Rss) + `,`,
		`TotalActiveAnon:` + fmt.Sprintf("%v", this.TotalActiveAnon) + `,`,
		`TotalActiveFile:` + fmt.Sprintf("%v", this.TotalActiveFile) + `,`,
		`TotalCache:` + fmt.Sprintf("%v", this.TotalCache) + `,`,
		`TotalInactiveAnon:` + fmt.Sprintf("%v", this.TotalInactiveAnon) + `,`,
		`TotalInactiveFile:` + fmt.Sprintf("%v", this.TotalInactiveFile) + `,`,
		`TotalMappedFile:` + fmt.Sprintf("%v", this.TotalMappedFile) + `,`,
		`TotalPgfault:` + fmt.Sprintf("%v", this.TotalPgfault) + `,`,
		`TotalPgmajfault:` + fmt.Sprintf("%v", this.TotalPgmajfault) + `,`,
		`TotalPgpgin:` + fmt.Sprintf("%v", this.TotalPgpgin) + `,`,
		`TotalPgpgout:` + fmt.Sprintf("%v", this.TotalPgpgout) + `,`,
		`TotalRss:` + fmt.Sprintf("%v", this.TotalRss) + `,`,
		`TotalUnevictable:` + fmt.Sprintf("%v", this.TotalUnevictable) + `,`,
		`Unevictable:` + fmt.Sprintf("%v", this.Unevictable) + `,`,
		`Swap:` + fmt.Sprintf("%v", this.Swap) + `,`,
		`HierarchicalMemswLimit:` + fmt.Sprintf("%v", this.HierarchicalMemswLimit) + `,`,
		`TotalSwap:` + fmt.Sprintf("%v", this.TotalSwap) + `,`,
		`TotalUsageTowardLimit:` + fmt.Sprintf("%v", this.TotalUsageTowardLimit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerCPUStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerCPUStat{`,
		`Usage:` + fmt.Sprintf("%v", this.Usage) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`System:` + fmt.Sprintf("%v", this.System) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerDiskStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerDiskStat{`,
		`TotalBytesUsed:` + fmt.Sprintf("%v", this.TotalBytesUsed) + `,`,
		`TotalInodesUsed:` + fmt.Sprintf("%v", this.TotalInodesUsed) + `,`,
		`ExclusiveBytesUsed:` + fmt.Sprintf("%v", this.ExclusiveBytesUsed) + `,`,
		`ExclusiveInodesUsed:` + fmt.Sprintf("%v", this.ExclusiveInodesUsed) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerNetworkStat{`,
		`RxBytes:` + fmt.Sprintf("%v", this.RxBytes) + `,`,
		`TxBytes:` + fmt.Sprintf("%v", this.TxBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StopMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StopMessage{`,
		`Kill:` + fmt.Sprintf("%v", this.Kill) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetInRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetInRequest{`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetInResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetInResponse{`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPRange{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortRange{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ICMPControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ICMPControl{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetOutRuleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetOutRuleRequest{`,
		`Networks:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Networks), "IPRange", "IPRange", 1), `&`, ``, 1) + `,`,
		`Ports:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Ports), "PortRange", "PortRange", 1), `&`, ``, 1) + `,`,
		`ICMPs:` + strings.Replace(fmt.Sprintf("%v", this.ICMPs), "ICMPControl", "ICMPControl", 1) + `,`,
		`Log:` + fmt.Sprintf("%v", this.Log) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BulkNetOutRuleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BulkNetOutRuleRequest{`,
		`NetOutRules:` + strings.Replace(fmt.Sprintf("%v", this.NetOutRules), "NetOutRuleRequest", "NetOutRuleRequest", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringContainer(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ProcessSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideContainerLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverrideContainerLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTY", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TTY.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindMounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindMounts = append(m.BindMounts, BindMount{})
			if err := m.BindMounts[len(m.BindMounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TTYSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TTYSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TTYSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WindowSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			m.Columns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Columns |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.As == nil {
				m.As = &google_protobuf1.UInt64Value{}
			}
			if err := m.As.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BandwidthLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BandwidthLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BandwidthLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateInBytesPerSecond", wireType)
			}
			m.RateInBytesPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateInBytesPerSecond |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstRateInBytesPerSecond", wireType)
			}
			m.BurstRateInBytesPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstRateInBytesPerSecond |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CPU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodeSoft", wireType)
			}
			m.InodeSoft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodeSoft |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodeHard", wireType)
			}
			m.InodeHard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodeHard |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteSoft", wireType)
			}
			m.ByteSoft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteSoft |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteHard", wireType)
			}
			m.ByteHard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteHard |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= (DiskLimitScope(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitInBytes", wireType)
			}
			m.LimitInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitInBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPULimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPULimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPULimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitInShares", wireType)
			}
			m.LimitInShares = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitInShares |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PidLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PidLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PidLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamInSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamInSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamInSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Part = &StreamInSpec_Path{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Part = &StreamInSpec_User{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Part = &StreamInSpec_Content{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamInResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamInResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamInResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamOutSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamOutSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamOutSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamOutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamOutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamOutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessIDs = append(m.ProcessIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &Properties{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappedPorts = append(m.MappedPorts, PortMapping{})
			if err := m.MappedPorts[len(m.MappedPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryStat == nil {
				m.MemoryStat = &ContainerMemoryStat{}
			}
			if err := m.MemoryStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CPUStat == nil {
				m.CPUStat = &ContainerCPUStat{}
			}
			if err := m.CPUStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiskStat == nil {
				m.DiskStat = &ContainerDiskStat{}
			}
			if err := m.DiskStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkStat == nil {
				m.NetworkStat = &ContainerNetworkStat{}
			}
			if err := m.NetworkStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerMemoryStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerMemoryStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerMemoryStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveAnon", wireType)
			}
			m.ActiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveAnon |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFile", wireType)
			}
			m.ActiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveFile |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			m.Cache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cache |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HierarchicalMemoryLimit", wireType)
			}
			m.HierarchicalMemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HierarchicalMemoryLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveAnon", wireType)
			}
			m.InactiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactiveAnon |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveFile", wireType)
			}
			m.InactiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactiveFile |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedFile", wireType)
			}
			m.MappedFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MappedFile |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgfault", wireType)
			}
			m.Pgfault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgfault |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgmajfault", wireType)
			}
			m.Pgmajfault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgmajfault |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgpgin", wireType)
			}
			m.Pgpgin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgpgin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgpgout", wireType)
			}
			m.Pgpgout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgpgout |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rss", wireType)
			}
			m.Rss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalActiveAnon", wireType)
			}
			m.TotalActiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalActiveAnon |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalActiveFile", wireType)
			}
			m.TotalActiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalActiveFile |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCache", wireType)
			}
			m.TotalCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCache |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalInactiveAnon", wireType)
			}
			m.TotalInactiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalInactiveAnon |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalInactiveFile", wireType)
			}
			m.TotalInactiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalInactiveFile |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMappedFile", wireType)
			}
			m.TotalMappedFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMappedFile |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPgfault", wireType)
			}
			m.TotalPgfault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPgfault |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPgmajfault", wireType)
			}
			m.TotalPgmajfault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPgmajfault |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPgpgin", wireType)
			}
			m.TotalPgpgin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPgpgin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPgpgout", wireType)
			}
			m.TotalPgpgout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPgpgout |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRss", wireType)
			}
			m.TotalRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUnevictable", wireType)
			}
			m.TotalUnevictable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUnevictable |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unevictable", wireType)
			}
			m.Unevictable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unevictable |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			m.Swap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Swap |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HierarchicalMemswLimit", wireType)
			}
			m.HierarchicalMemswLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HierarchicalMemswLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSwap", wireType)
			}
			m.TotalSwap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSwap |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsageTowardLimit", wireType)
			}
			m.TotalUsageTowardLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsageTowardLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerCPUStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerCPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerCPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			m.Usage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usage |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			m.User = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			m.System = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.System |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerDiskStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerDiskStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerDiskStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytesUsed", wireType)
			}
			m.TotalBytesUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytesUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalInodesUsed", wireType)
			}
			m.TotalInodesUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalInodesUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveBytesUsed", wireType)
			}
			m.ExclusiveBytesUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExclusiveBytesUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveInodesUsed", wireType)
			}
			m.ExclusiveInodesUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExclusiveInodesUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
			}
			m.RxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
			}
			m.TxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kill", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kill = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetInRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetInRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetInRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetInResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetInResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetInResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetOutRuleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetOutRuleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetOutRuleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Networks = append(m.Networks, IPRange{})
			if err := m.Networks[len(m.Networks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, PortRange{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ICMPs == nil {
				m.ICMPs = &ICMPControl{}
			}
			if err := m.ICMPs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Log = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkNetOutRuleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkNetOutRuleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkNetOutRuleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetOutRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetOutRules = append(m.NetOutRules, &NetOutRuleRequest{})
			if err := m.NetOutRules[len(m.NetOutRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipContainer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthContainer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipContainer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthContainer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowContainer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("container.proto", fileDescriptorContainer) }

var fileDescriptorContainer = []byte{
	// 2025 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x73, 0xe3, 0x48,
	0x15, 0x8f, 0xff, 0xc7, 0xcf, 0x76, 0xe2, 0x74, 0x32, 0x13, 0x25, 0x9b, 0xb1, 0x82, 0x60, 0xb7,
	0x06, 0x6a, 0x36, 0xc3, 0x64, 0x97, 0xa1, 0x0a, 0xa6, 0x66, 0x89, 0x13, 0xef, 0xc6, 0xb0, 0x99,
	0x31, 0x6d, 0x87, 0xad, 0xbd, 0x6c, 0x4a, 0x63, 0x77, 0x1c, 0xb1, 0xb2, 0x24, 0x24, 0x39, 0x9e,
	0x70, 0xa2, 0xe0, 0x0b, 0x70, 0xe5, 0x1b, 0x50, 0x7c, 0x02, 0xbe, 0x01, 0x73, 0xe0, 0xb0, 0x47,
	0x4e, 0x2e, 0x26, 0x5c, 0x28, 0x9f, 0xf6, 0x0b, 0x50, 0x45, 0xf5, 0xeb, 0x96, 0xd4, 0xb2, 0x9d,
	0xb9, 0xc0, 0x4d, 0xfd, 0x7b, 0xbf, 0xdf, 0xd3, 0x7b, 0xad, 0xd7, 0xaf, 0x9f, 0x0d, 0xeb, 0x7d,
	0xd7, 0x09, 0x4d, 0xcb, 0x61, 0xfe, 0x81, 0xe7, 0xbb, 0xa1, 0x4b, 0xea, 0xd7, 0x31, 0x32, 0x72,
	0x07, 0xcc, 0x0e, 0x76, 0xab, 0x7d, 0x77, 0x34, 0x72, 0x1d, 0x61, 0xdf, 0x6d, 0x0c, 0x5d, 0x77,
	0x68, 0xb3, 0xc7, 0xb8, 0x7a, 0x35, 0xbe, 0x7c, 0x3c, 0xf1, 0x4d, 0xcf, 0x63, 0x7e, 0x20, 0xed,
	0x1f, 0x0e, 0xad, 0xf0, 0x6a, 0xfc, 0xea, 0xa0, 0xef, 0x8e, 0x1e, 0x0f, 0xdd, 0xa1, 0x9b, 0x10,
	0xf9, 0x0a, 0x17, 0xf8, 0x24, 0xe8, 0xc6, 0xdf, 0x73, 0x50, 0xe9, 0xf8, 0x6e, 0x9f, 0x05, 0x41,
	0xd7, 0x63, 0x7d, 0xb2, 0x06, 0xd9, 0xf6, 0x89, 0x96, 0xd9, 0xcf, 0x3c, 0x2c, 0xd3, 0x6c, 0xfb,
	0x84, 0x10, 0xc8, 0x77, 0xcc, 0xf0, 0x4a, 0xcb, 0x22, 0x82, 0xcf, 0x1c, 0x3b, 0xf2, 0x87, 0x81,
	0x96, 0xdb, 0xcf, 0x71, 0x8c, 0x3f, 0x93, 0x3a, 0xe4, 0x5a, 0xce, 0xb5, 0x96, 0x47, 0x88, 0x3f,
	0x72, 0xe4, 0xc4, 0xf2, 0xb5, 0x02, 0x0a, 0xf9, 0x23, 0xd7, 0x9d, 0x07, 0xcc, 0xd7, 0x8a, 0xc2,
	0x17, 0x7f, 0x26, 0xcf, 0xa1, 0xf8, 0xb9, 0x35, 0xb2, 0xc2, 0x40, 0x2b, 0xed, 0x67, 0x1e, 0x56,
	0x0e, 0xf7, 0x0f, 0xe6, 0xf3, 0x3f, 0xa0, 0x2c, 0x70, 0xc7, 0x7e, 0x9f, 0x09, 0x5e, 0x33, 0xff,
	0x66, 0xaa, 0xaf, 0x50, 0xa9, 0x22, 0x17, 0xb0, 0xfd, 0xf2, 0x9a, 0xf9, 0xbe, 0x35, 0x60, 0xc7,
	0x91, 0x4e, 0x3a, 0x5c, 0x45, 0x87, 0xfa, 0xa2, 0x43, 0x99, 0x6f, 0xca, 0xdf, 0x5d, 0x5e, 0xc8,
	0x13, 0xc8, 0xf5, 0x7a, 0x5f, 0x6a, 0x65, 0x74, 0xb6, 0xb3, 0xe8, 0xac, 0xd7, 0xfb, 0x92, 0x6f,
	0x9c, 0x74, 0xc3, 0xb9, 0xe4, 0x29, 0x14, 0xda, 0x23, 0x73, 0xc8, 0x34, 0x40, 0xd1, 0xee, 0xa2,
	0x08, 0xcd, 0x94, 0x5d, 0x4a, 0x95, 0xa0, 0x93, 0x23, 0x80, 0xa6, 0xe5, 0x0c, 0xce, 0xdc, 0xb1,
	0x13, 0x06, 0x5a, 0x65, 0x3f, 0xf7, 0xb0, 0x72, 0xf8, 0xde, 0xa2, 0x38, 0xe6, 0x48, 0xb5, 0x22,
	0x32, 0x7e, 0x0a, 0x15, 0x3a, 0x76, 0x28, 0x0b, 0x3c, 0xd7, 0x09, 0xd8, 0xc2, 0xd7, 0xdc, 0x83,
	0xb2, 0x4c, 0xbe, 0x3d, 0x90, 0x9f, 0x34, 0x01, 0x8c, 0x33, 0x28, 0xc9, 0x6c, 0x48, 0x13, 0xe0,
	0x0b, 0xcb, 0x19, 0xb8, 0x93, 0xae, 0xf5, 0x5b, 0x86, 0x0e, 0x2a, 0x87, 0x7b, 0x8b, 0xa1, 0x24,
	0x9c, 0x28, 0x96, 0x04, 0x31, 0x7e, 0xa2, 0xfa, 0x20, 0x1a, 0x94, 0x8e, 0x5d, 0x7b, 0x3c, 0x72,
	0x02, 0x74, 0x57, 0xa0, 0xd1, 0x92, 0x97, 0x05, 0x75, 0x27, 0x01, 0xc6, 0x53, 0xa0, 0xf8, 0x6c,
	0x3c, 0x87, 0xb5, 0xf4, 0x67, 0x27, 0x8f, 0x20, 0x7b, 0x14, 0xc4, 0x91, 0x88, 0x43, 0x70, 0x10,
	0xd5, 0xf6, 0xc1, 0x79, 0xdb, 0x09, 0x9f, 0x7e, 0xfc, 0x2b, 0xd3, 0x1e, 0x33, 0x9a, 0x3d, 0x0a,
	0x8c, 0x3f, 0x64, 0x60, 0xbd, 0x69, 0x3a, 0x83, 0x89, 0x35, 0x08, 0xaf, 0xa4, 0x87, 0x43, 0xd8,
	0xa2, 0x66, 0xc8, 0xda, 0x4e, 0xf3, 0x26, 0x64, 0x41, 0x87, 0xf9, 0x5d, 0xd6, 0x77, 0x9d, 0x01,
	0xfa, 0xcc, 0xd3, 0xa5, 0x36, 0xf2, 0x0c, 0x76, 0x9a, 0x63, 0x3f, 0x08, 0x97, 0x0a, 0xb3, 0x28,
	0xbc, 0x9b, 0x60, 0xfc, 0x3e, 0x03, 0xb5, 0x54, 0xb1, 0x91, 0x8f, 0x20, 0x77, 0xdc, 0x39, 0x97,
	0x69, 0x2c, 0xf9, 0xb6, 0xc7, 0x9d, 0xf3, 0x54, 0x59, 0x72, 0x36, 0x79, 0x06, 0xc5, 0x33, 0x36,
	0x72, 0xfd, 0x1b, 0x7c, 0x63, 0xe5, 0xb0, 0xb1, 0xa8, 0x13, 0xf6, 0xf4, 0x09, 0x11, 0x98, 0xf1,
	0xd7, 0x0c, 0xc0, 0x89, 0x15, 0x7c, 0x2d, 0x23, 0xd8, 0x83, 0x72, 0xdb, 0x71, 0x07, 0xac, 0xeb,
	0x5e, 0x86, 0x32, 0xf5, 0x04, 0x88, 0xad, 0xa7, 0xa6, 0x1f, 0xe5, 0x97, 0x00, 0x64, 0x17, 0x56,
	0x79, 0x86, 0x28, 0xcd, 0xa1, 0x31, 0x5e, 0x47, 0x36, 0x14, 0xe6, 0x13, 0x1b, 0xea, 0x9e, 0x42,
	0xa1, 0xdb, 0x77, 0x3d, 0x86, 0xcd, 0x60, 0x6d, 0xd9, 0x19, 0x8f, 0x03, 0x44, 0x1e, 0x15, 0x74,
	0xe3, 0x10, 0xaa, 0x6a, 0x62, 0xc4, 0x80, 0x2a, 0x3e, 0xc9, 0x8d, 0x96, 0xe1, 0xa7, 0x30, 0xe3,
	0x09, 0x94, 0xe3, 0x4d, 0x24, 0xdf, 0x83, 0x9a, 0x34, 0x76, 0xaf, 0x4c, 0x3f, 0x56, 0xa4, 0x41,
	0xe3, 0x01, 0x94, 0x3b, 0xd6, 0x40, 0x4a, 0xea, 0x90, 0x3b, 0x33, 0x5f, 0x4b, 0x22, 0x7f, 0x34,
	0x5e, 0x42, 0xa5, 0xe3, 0xfa, 0xe1, 0x99, 0xe9, 0x79, 0x96, 0x33, 0xe4, 0x89, 0x9e, 0xba, 0x41,
	0xc8, 0x21, 0x64, 0xd5, 0x68, 0xbc, 0xe6, 0xef, 0x8b, 0xfb, 0x07, 0x12, 0xb2, 0x48, 0x48, 0x83,
	0xc6, 0x57, 0x50, 0xed, 0x86, 0x3e, 0x33, 0x47, 0x6d, 0x07, 0x0f, 0xdb, 0x96, 0xec, 0xb1, 0x78,
	0x4e, 0x4f, 0x57, 0x64, 0x97, 0xdd, 0x92, 0xdd, 0x32, 0x1b, 0xa1, 0xd8, 0x2f, 0x77, 0xf9, 0x31,
	0x72, 0x42, 0xe6, 0x88, 0x2f, 0x50, 0x3d, 0x5d, 0xa1, 0x11, 0xd0, 0x2c, 0x72, 0x3f, 0x7e, 0x68,
	0x3c, 0x82, 0x7a, 0xe4, 0x3f, 0xee, 0x04, 0x1a, 0x94, 0xce, 0x58, 0x10, 0xf0, 0xae, 0x24, 0xda,
	0x41, 0xb4, 0x34, 0x7e, 0x0c, 0x35, 0xc1, 0x7e, 0x39, 0x0e, 0x31, 0x1c, 0xa2, 0x86, 0x93, 0xb4,
	0xfc, 0x24, 0x18, 0x11, 0x8a, 0xf1, 0x21, 0x6c, 0xc4, 0x42, 0xf5, 0x3d, 0x51, 0x7c, 0x5c, 0x5f,
	0x8d, 0xa3, 0x33, 0x6e, 0xb3, 0xca, 0xe6, 0xb4, 0x9d, 0x4b, 0x97, 0x6c, 0x41, 0xa1, 0x1b, 0x9a,
	0x61, 0x14, 0x91, 0x58, 0x90, 0xfb, 0x50, 0x6c, 0x5d, 0x33, 0xde, 0x01, 0xb3, 0x78, 0x99, 0xc8,
	0x15, 0xc7, 0xf9, 0x3e, 0xb7, 0x3b, 0x98, 0x78, 0x99, 0xca, 0x15, 0xd9, 0x87, 0x4a, 0xe2, 0xb6,
	0x83, 0xb5, 0x57, 0xa6, 0x2a, 0x44, 0x1a, 0x00, 0xad, 0xd7, 0x21, 0xf3, 0x1d, 0xd3, 0x6e, 0x77,
	0xe4, 0x85, 0xa4, 0x20, 0xe9, 0xaf, 0xc6, 0x33, 0x17, 0x17, 0x54, 0x1a, 0xe4, 0x5e, 0xa2, 0x56,
	0x79, 0xc2, 0x6f, 0x2b, 0x1e, 0x9b, 0x82, 0x90, 0x67, 0x68, 0xf7, 0x98, 0x1f, 0x5a, 0x2c, 0xba,
	0x7c, 0xf6, 0x96, 0x5e, 0x3e, 0x92, 0x43, 0x15, 0x3e, 0x69, 0x41, 0x85, 0x17, 0x18, 0x1b, 0xf0,
	0x0a, 0x09, 0xb4, 0x32, 0x36, 0xff, 0x07, 0x4b, 0xe4, 0x49, 0x25, 0xca, 0x73, 0xae, 0xea, 0x8c,
	0x3f, 0x65, 0xf9, 0x77, 0x0e, 0x7d, 0xab, 0xcf, 0x5d, 0x82, 0x38, 0x3d, 0x7c, 0x5f, 0x65, 0xcb,
	0x79, 0x7f, 0x49, 0xcb, 0x89, 0xd6, 0x09, 0x99, 0x2a, 0x42, 0xf2, 0x0c, 0x4a, 0xc7, 0x9d, 0x73,
	0xf4, 0x21, 0xda, 0x8f, 0xf1, 0x0e, 0x1f, 0x92, 0x49, 0x23, 0x09, 0xf9, 0x04, 0x56, 0xf9, 0xd9,
	0x46, 0x79, 0x0e, 0xe5, 0xdf, 0x7d, 0x87, 0x3c, 0xa2, 0xd2, 0x58, 0x44, 0x4e, 0xa1, 0xf2, 0x82,
	0x85, 0x13, 0xd7, 0x17, 0x3e, 0xf2, 0xe8, 0xe3, 0x83, 0x77, 0xf8, 0x50, 0xd8, 0x54, 0x95, 0x1a,
	0x7f, 0xa9, 0xc2, 0xe6, 0x92, 0x64, 0xc9, 0x63, 0x80, 0xa3, 0x7e, 0x68, 0x5d, 0xb3, 0x23, 0xc7,
	0x75, 0xc4, 0xc1, 0x6f, 0xae, 0xcf, 0xa6, 0x7a, 0xc5, 0x44, 0xf4, 0xc2, 0x74, 0x5c, 0x87, 0x2a,
	0x94, 0x44, 0xf0, 0xa9, 0x65, 0x33, 0xd1, 0x25, 0x53, 0x82, 0x4b, 0xcb, 0x66, 0x54, 0xa1, 0x10,
	0x1d, 0x0a, 0xc7, 0x66, 0xff, 0x8a, 0x89, 0xa6, 0xd9, 0x2c, 0xcf, 0xa6, 0x7a, 0xa1, 0xcf, 0x01,
	0x2a, 0x70, 0xf2, 0x05, 0x6c, 0x9f, 0x5a, 0xcc, 0x37, 0xfd, 0xfe, 0x95, 0xd5, 0x37, 0x6d, 0xa5,
	0xe9, 0x89, 0x5e, 0xda, 0x7c, 0x30, 0x9b, 0xea, 0x3b, 0x57, 0x0a, 0xe5, 0x62, 0x84, 0x9c, 0x0b,
	0x9b, 0x93, 0xe8, 0x5d, 0x6a, 0xf2, 0x23, 0xa8, 0xb6, 0x1d, 0x33, 0xc9, 0xae, 0x80, 0xde, 0x36,
	0x66, 0x53, 0xbd, 0x66, 0x39, 0x6a, 0x7e, 0x29, 0x9a, 0x2a, 0xc3, 0x1c, 0x8b, 0x4b, 0x64, 0x98,
	0x65, 0x8a, 0xc6, 0x37, 0x46, 0x14, 0x23, 0x8a, 0x4a, 0xc9, 0xc6, 0x8c, 0x10, 0x95, 0x1b, 0x93,
	0x50, 0xc8, 0xfb, 0x50, 0xea, 0x0c, 0x2f, 0xcd, 0xb1, 0x1d, 0xe2, 0x81, 0xc9, 0x37, 0x2b, 0xb3,
	0xa9, 0x5e, 0xf2, 0x04, 0x44, 0x23, 0x1b, 0x39, 0x00, 0xe8, 0x0c, 0x47, 0xe6, 0xaf, 0x05, 0xb3,
	0x8c, 0xcc, 0xb5, 0xd9, 0x54, 0x07, 0x2f, 0x46, 0xa9, 0xc2, 0x20, 0x06, 0x14, 0x3b, 0x43, 0x6f,
	0x68, 0x39, 0x38, 0x81, 0xe5, 0x9b, 0x30, 0x9b, 0xea, 0x45, 0x0f, 0x11, 0x2a, 0x2d, 0xe2, 0xd5,
	0xde, 0xd0, 0x1d, 0x87, 0x5a, 0x45, 0x7d, 0x35, 0x42, 0x34, 0xb2, 0x91, 0x1d, 0xc8, 0xd1, 0x20,
	0xd0, 0xaa, 0x48, 0x29, 0xcd, 0xa6, 0x7a, 0xce, 0x0f, 0x02, 0xca, 0x31, 0xf2, 0x09, 0xac, 0xf7,
	0xdc, 0xd0, 0xb4, 0x95, 0xe2, 0xa9, 0x21, 0xed, 0xde, 0x6c, 0xaa, 0x6f, 0x84, 0xdc, 0x74, 0xa1,
	0x6e, 0xf1, 0x3c, 0x7b, 0xce, 0x01, 0xee, 0xd9, 0xda, 0x1d, 0x0e, 0x70, 0xe7, 0xe6, 0xd9, 0x7c,
	0xbf, 0x11, 0x12, 0xc5, 0xb5, 0x9e, 0xec, 0xb7, 0xd0, 0x8a, 0x12, 0x53, 0x28, 0xa4, 0x05, 0x1b,
	0xb8, 0x4a, 0xd5, 0x44, 0x1d, 0x75, 0xdb, 0xb3, 0xa9, 0xbe, 0x29, 0x74, 0xe9, 0xca, 0x58, 0x54,
	0x2c, 0xb8, 0xc1, 0xd0, 0x37, 0xee, 0x74, 0x83, 0xc1, 0x2f, 0x2a, 0xe2, 0xfc, 0x95, 0x9a, 0x21,
	0xf3, 0xf9, 0xab, 0x95, 0x33, 0xcf, 0xe6, 0x65, 0x8a, 0x50, 0x54, 0x43, 0x9b, 0x49, 0x99, 0x0a,
	0x75, 0x54, 0x49, 0x29, 0x1a, 0x79, 0x2e, 0xdf, 0xab, 0xd4, 0xd4, 0x16, 0x2a, 0xb7, 0x66, 0x53,
	0xbd, 0x1e, 0x29, 0xe3, 0xca, 0x9a, 0x27, 0x93, 0x43, 0xa8, 0x48, 0x08, 0x6b, 0xec, 0x1e, 0x6a,
	0xeb, 0xb3, 0xa9, 0x5e, 0x8d, 0xb4, 0x58, 0x69, 0x2a, 0x49, 0x09, 0x55, 0xd4, 0xdc, 0xfd, 0xc5,
	0x50, 0x45, 0xe5, 0xa5, 0x68, 0xe4, 0xfb, 0xb0, 0x8a, 0x6b, 0x5e, 0x83, 0xdb, 0x28, 0xa9, 0xcd,
	0xa6, 0x7a, 0x59, 0x48, 0x78, 0x25, 0xc6, 0x66, 0x72, 0x04, 0x75, 0x7c, 0x3e, 0x77, 0xd8, 0xb5,
	0xd5, 0x0f, 0xcd, 0x57, 0x36, 0xd3, 0xb4, 0xf9, 0xed, 0x1c, 0x27, 0x46, 0xba, 0x40, 0x27, 0x4f,
	0xa0, 0xa2, 0xaa, 0x77, 0x92, 0x82, 0x52, 0x75, 0x2a, 0x87, 0xec, 0x41, 0xbe, 0x3b, 0x31, 0x3d,
	0x6d, 0x17, 0xb9, 0xab, 0xb3, 0xa9, 0x9e, 0x0f, 0x26, 0xa6, 0x47, 0x11, 0x25, 0x3d, 0xb8, 0x3f,
	0xd7, 0x99, 0x82, 0x89, 0x68, 0x6b, 0xef, 0x21, 0x7f, 0x6f, 0x36, 0xd5, 0xb5, 0xf9, 0xb6, 0x16,
	0x4c, 0x64, 0x57, 0xbb, 0x43, 0x4b, 0x1e, 0x41, 0x19, 0x43, 0xc7, 0x17, 0xef, 0x25, 0xdd, 0x40,
	0xa4, 0x88, 0xaf, 0x4f, 0x08, 0xe4, 0x63, 0xb8, 0x27, 0x12, 0xe5, 0xd3, 0x4e, 0xcf, 0x9d, 0x98,
	0xbe, 0x18, 0xf5, 0xb4, 0x07, 0x38, 0xe2, 0x2d, 0x37, 0x1a, 0x3d, 0xa8, 0xcf, 0x5f, 0x6a, 0x7c,
	0x5e, 0x39, 0x8f, 0x27, 0xa8, 0x3c, 0x15, 0x8b, 0xd4, 0x68, 0x94, 0x97, 0x53, 0xda, 0x7d, 0x28,
	0x76, 0x6f, 0x82, 0x90, 0x8d, 0xe4, 0x98, 0x2c, 0x57, 0xc6, 0xdf, 0x32, 0xb0, 0xb1, 0x70, 0xd9,
	0x91, 0x0f, 0x60, 0x0d, 0x83, 0xc0, 0x01, 0xf6, 0x3c, 0x60, 0xd1, 0x4f, 0x92, 0x39, 0x94, 0x3c,
	0x94, 0x75, 0x8b, 0x03, 0xb9, 0x20, 0x8a, 0x97, 0xce, 0xc3, 0xe4, 0x00, 0x48, 0xeb, 0x75, 0xdf,
	0x1e, 0x07, 0xd6, 0x35, 0x4b, 0xbc, 0x8a, 0x58, 0x96, 0x58, 0xc8, 0x0f, 0x61, 0x33, 0x46, 0x15,
	0xef, 0x62, 0x8e, 0x5f, 0x66, 0x32, 0x7e, 0x0e, 0x5b, 0xcb, 0x6e, 0x5c, 0x3e, 0xff, 0xd1, 0xd7,
	0xea, 0x74, 0x1e, 0x2d, 0xb9, 0xa5, 0x27, 0x2d, 0x22, 0xea, 0x68, 0x69, 0x7c, 0x07, 0x2a, 0xdd,
	0xd0, 0xf5, 0xe4, 0x40, 0xca, 0x37, 0xf4, 0x17, 0x96, 0x6d, 0xa3, 0x7e, 0x95, 0xe2, 0xb3, 0xd1,
	0x81, 0xea, 0x0b, 0x16, 0xf2, 0x79, 0xf6, 0x37, 0x63, 0x16, 0x84, 0xff, 0x87, 0x21, 0xfc, 0x97,
	0x50, 0x93, 0x1e, 0xe5, 0xe4, 0xfa, 0xbf, 0xbb, 0x6c, 0x41, 0xa9, 0xdd, 0xa1, 0xa6, 0x33, 0xc4,
	0x1b, 0xbf, 0x1b, 0x9a, 0xd2, 0x53, 0x55, 0xdc, 0xf8, 0x01, 0x07, 0xa8, 0xc0, 0xf9, 0xbd, 0xd2,
	0x92, 0x3f, 0x21, 0xab, 0xe2, 0x5e, 0x61, 0xce, 0x80, 0x72, 0xcc, 0xf8, 0x0c, 0xca, 0xdc, 0xdd,
	0x12, 0x47, 0xb5, 0x77, 0x3b, 0xaa, 0xcd, 0x39, 0x3a, 0x83, 0x4a, 0xfb, 0xf8, 0xac, 0xc3, 0x83,
	0xf4, 0x5d, 0x9b, 0x1f, 0xd5, 0xde, 0x8d, 0xc7, 0xa4, 0x27, 0x3c, 0xaa, 0xe1, 0x8d, 0xc7, 0x28,
	0xa2, 0x64, 0x1f, 0xf2, 0xc7, 0xee, 0x80, 0x49, 0x47, 0xd5, 0x37, 0x53, 0x3d, 0x93, 0x30, 0xb8,
	0xc5, 0xf8, 0x4f, 0x06, 0x36, 0x5e, 0xb0, 0x90, 0x4f, 0xfb, 0x63, 0x9b, 0x45, 0x5f, 0xe2, 0x33,
	0x58, 0x95, 0xdf, 0x5f, 0x0c, 0xec, 0x4b, 0xff, 0x24, 0x91, 0xdb, 0xd2, 0xac, 0xf3, 0x89, 0x75,
	0x36, 0xd5, 0x57, 0x1d, 0x29, 0xa1, 0xb1, 0x98, 0xfc, 0x0c, 0x0a, 0x62, 0xf6, 0xcd, 0xdd, 0xf5,
	0xc7, 0x47, 0xbc, 0x2b, 0xcd, 0x9a, 0xf4, 0x53, 0xf0, 0xb8, 0x82, 0x0a, 0x21, 0x69, 0x42, 0x81,
	0xe7, 0x1b, 0xc8, 0x21, 0x71, 0xc9, 0xf4, 0xac, 0x6c, 0x07, 0xfa, 0xe0, 0x29, 0x16, 0xac, 0xfe,
	0xc8, 0x0b, 0xa8, 0x90, 0xf2, 0xed, 0xfc, 0xdc, 0x1d, 0xe2, 0x9c, 0xb4, 0x2a, 0xb6, 0xd3, 0x76,
	0x87, 0x94, 0x63, 0xc6, 0x57, 0x70, 0xaf, 0x39, 0xb6, 0xbf, 0x5e, 0xdc, 0x82, 0x16, 0x8e, 0xa8,
	0x12, 0xe4, 0x75, 0x9f, 0x5b, 0x3e, 0xe6, 0x2e, 0x28, 0xa9, 0xaa, 0xfb, 0xc1, 0xa7, 0xb0, 0x96,
	0xfe, 0x19, 0x4c, 0xb6, 0x61, 0x33, 0x8d, 0xe0, 0x39, 0xaf, 0xaf, 0x90, 0xf7, 0x60, 0x3b, 0x6d,
	0x88, 0x8f, 0x68, 0x3d, 0xd3, 0x7c, 0xf4, 0xcd, 0xdb, 0xc6, 0xca, 0x3f, 0xde, 0x36, 0x56, 0xbe,
	0x7d, 0xdb, 0xc8, 0xfc, 0xee, 0xb6, 0x91, 0xf9, 0xf3, 0x6d, 0x23, 0xf3, 0xe6, 0xb6, 0x91, 0xf9,
	0xe6, 0xb6, 0x91, 0xf9, 0xe7, 0x6d, 0x23, 0xf3, 0xef, 0xdb, 0xc6, 0xca, 0xb7, 0xb7, 0x8d, 0xcc,
	0x1f, 0xff, 0xd5, 0x58, 0x79, 0x55, 0xc4, 0xff, 0x50, 0x3e, 0xfa, 0x6f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x48, 0x43, 0x69, 0x5c, 0x89, 0x14, 0x00, 0x00,
}
