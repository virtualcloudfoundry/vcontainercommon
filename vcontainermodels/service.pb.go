// Code generated by protoc-gen-gogo.
// source: service.proto
// DO NOT EDIT!

package vcontainermodels

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf2 "github.com/gogo/protobuf/types"
import google_protobuf3 "github.com/gogo/protobuf/types"
import google_protobuf1 "github.com/gogo/protobuf/types"

import strings "strings"
import reflect "reflect"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ContainersResponse struct {
	// TODO only a place holder.
	Handle []string `protobuf:"bytes,1,rep,name=Handle" json:"Handle,omitempty"`
}

func (m *ContainersResponse) Reset()                    { *m = ContainersResponse{} }
func (*ContainersResponse) ProtoMessage()               {}
func (*ContainersResponse) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{0} }

func (m *ContainersResponse) GetHandle() []string {
	if m != nil {
		return m.Handle
	}
	return nil
}

// the container service messages
type StopRequest struct {
	Kill bool `protobuf:"varint,1,opt,name=Kill,proto3" json:"Kill,omitempty"`
}

func (m *StopRequest) Reset()                    { *m = StopRequest{} }
func (*StopRequest) ProtoMessage()               {}
func (*StopRequest) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{1} }

func (m *StopRequest) GetKill() bool {
	if m != nil {
		return m.Kill
	}
	return false
}

type StopResponse struct {
}

func (m *StopResponse) Reset()                    { *m = StopResponse{} }
func (*StopResponse) ProtoMessage()               {}
func (*StopResponse) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{2} }

func init() {
	proto.RegisterType((*ContainersResponse)(nil), "vcontainermodels.ContainersResponse")
	proto.RegisterType((*StopRequest)(nil), "vcontainermodels.StopRequest")
	proto.RegisterType((*StopResponse)(nil), "vcontainermodels.StopResponse")
}
func (this *ContainersResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainersResponse)
	if !ok {
		that2, ok := that.(ContainersResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Handle) != len(that1.Handle) {
		return false
	}
	for i := range this.Handle {
		if this.Handle[i] != that1.Handle[i] {
			return false
		}
	}
	return true
}
func (this *StopRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StopRequest)
	if !ok {
		that2, ok := that.(StopRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Kill != that1.Kill {
		return false
	}
	return true
}
func (this *StopResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StopResponse)
	if !ok {
		that2, ok := that.(StopResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *ContainersResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.ContainersResponse{")
	s = append(s, "Handle: "+fmt.Sprintf("%#v", this.Handle)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StopRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&vcontainermodels.StopRequest{")
	s = append(s, "Kill: "+fmt.Sprintf("%#v", this.Kill)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StopResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&vcontainermodels.StopResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringService(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for VGarden service

type VGardenClient interface {
	Ping(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	Capacity(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*Capacity, error)
	Create(ctx context.Context, in *ContainerSpec, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	Destroy(ctx context.Context, in *google_protobuf1.StringValue, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	Containers(ctx context.Context, in *Properties, opts ...grpc.CallOption) (*ContainersResponse, error)
	BulkInfo(ctx context.Context, in *BulkInfoRequest, opts ...grpc.CallOption) (*BulkInfoResponse, error)
	BulkMetrics(ctx context.Context, in *BulkMetricsRequest, opts ...grpc.CallOption) (*BulkMetricsResponse, error)
	// client always sends a big file to the server.
	// rpc SendFile(stream BigFileChunk) returns (BigFileAck) {}
	Lookup(ctx context.Context, in *google_protobuf1.StringValue, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
}

type vGardenClient struct {
	cc *grpc.ClientConn
}

func NewVGardenClient(cc *grpc.ClientConn) VGardenClient {
	return &vGardenClient{cc}
}

func (c *vGardenClient) Ping(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VGarden/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vGardenClient) Capacity(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*Capacity, error) {
	out := new(Capacity)
	err := grpc.Invoke(ctx, "/vcontainermodels.VGarden/Capacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vGardenClient) Create(ctx context.Context, in *ContainerSpec, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VGarden/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vGardenClient) Destroy(ctx context.Context, in *google_protobuf1.StringValue, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VGarden/Destroy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vGardenClient) Containers(ctx context.Context, in *Properties, opts ...grpc.CallOption) (*ContainersResponse, error) {
	out := new(ContainersResponse)
	err := grpc.Invoke(ctx, "/vcontainermodels.VGarden/Containers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vGardenClient) BulkInfo(ctx context.Context, in *BulkInfoRequest, opts ...grpc.CallOption) (*BulkInfoResponse, error) {
	out := new(BulkInfoResponse)
	err := grpc.Invoke(ctx, "/vcontainermodels.VGarden/BulkInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vGardenClient) BulkMetrics(ctx context.Context, in *BulkMetricsRequest, opts ...grpc.CallOption) (*BulkMetricsResponse, error) {
	out := new(BulkMetricsResponse)
	err := grpc.Invoke(ctx, "/vcontainermodels.VGarden/BulkMetrics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vGardenClient) Lookup(ctx context.Context, in *google_protobuf1.StringValue, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VGarden/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VGarden service

type VGardenServer interface {
	Ping(context.Context, *google_protobuf3.Empty) (*google_protobuf3.Empty, error)
	Capacity(context.Context, *google_protobuf3.Empty) (*Capacity, error)
	Create(context.Context, *ContainerSpec) (*google_protobuf3.Empty, error)
	Destroy(context.Context, *google_protobuf1.StringValue) (*google_protobuf3.Empty, error)
	Containers(context.Context, *Properties) (*ContainersResponse, error)
	BulkInfo(context.Context, *BulkInfoRequest) (*BulkInfoResponse, error)
	BulkMetrics(context.Context, *BulkMetricsRequest) (*BulkMetricsResponse, error)
	// client always sends a big file to the server.
	// rpc SendFile(stream BigFileChunk) returns (BigFileAck) {}
	Lookup(context.Context, *google_protobuf1.StringValue) (*google_protobuf3.Empty, error)
}

func RegisterVGardenServer(s *grpc.Server, srv VGardenServer) {
	s.RegisterService(&_VGarden_serviceDesc, srv)
}

func _VGarden_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf3.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VGardenServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VGarden/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VGardenServer).Ping(ctx, req.(*google_protobuf3.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VGarden_Capacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf3.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VGardenServer).Capacity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VGarden/Capacity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VGardenServer).Capacity(ctx, req.(*google_protobuf3.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VGarden_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VGardenServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VGarden/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VGardenServer).Create(ctx, req.(*ContainerSpec))
	}
	return interceptor(ctx, in, info, handler)
}

func _VGarden_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VGardenServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VGarden/Destroy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VGardenServer).Destroy(ctx, req.(*google_protobuf1.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _VGarden_Containers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Properties)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VGardenServer).Containers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VGarden/Containers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VGardenServer).Containers(ctx, req.(*Properties))
	}
	return interceptor(ctx, in, info, handler)
}

func _VGarden_BulkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VGardenServer).BulkInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VGarden/BulkInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VGardenServer).BulkInfo(ctx, req.(*BulkInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VGarden_BulkMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VGardenServer).BulkMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VGarden/BulkMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VGardenServer).BulkMetrics(ctx, req.(*BulkMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VGarden_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VGardenServer).Lookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VGarden/Lookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VGardenServer).Lookup(ctx, req.(*google_protobuf1.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

var _VGarden_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vcontainermodels.VGarden",
	HandlerType: (*VGardenServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _VGarden_Ping_Handler,
		},
		{
			MethodName: "Capacity",
			Handler:    _VGarden_Capacity_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _VGarden_Create_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _VGarden_Destroy_Handler,
		},
		{
			MethodName: "Containers",
			Handler:    _VGarden_Containers_Handler,
		},
		{
			MethodName: "BulkInfo",
			Handler:    _VGarden_BulkInfo_Handler,
		},
		{
			MethodName: "BulkMetrics",
			Handler:    _VGarden_BulkMetrics_Handler,
		},
		{
			MethodName: "Lookup",
			Handler:    _VGarden_Lookup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// Client API for VContainer service

type VContainerClient interface {
	// rpc Handle(google.protobuf.Empty) returns(string) {}
	Run(ctx context.Context, in *ProcessSpec, opts ...grpc.CallOption) (*RunResponse, error)
	Stop(ctx context.Context, in *StopMessage, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	Metrics(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*Metrics, error)
	// Sets the grace time.
	SetGraceTime(ctx context.Context, in *google_protobuf2.Duration, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	// Properties returns the current set of properties
	Properties(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*Properties, error)
	Info(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*ContainerInfo, error)
	NetIn(ctx context.Context, in *NetInRequest, opts ...grpc.CallOption) (*NetInResponse, error)
	NetOut(ctx context.Context, in *NetOutRuleRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	BulkNetOut(ctx context.Context, in *BulkNetOutRuleRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	// Property returns the value of the property with the specified name.
	//
	// Errors:
	// * When the property does not exist on the container.
	Property(ctx context.Context, in *google_protobuf1.StringValue, opts ...grpc.CallOption) (*google_protobuf1.StringValue, error)
	// Set a named property on a container to a specified value.
	//
	// Errors:
	// * None.
	SetProperty(ctx context.Context, in *KeyValueMessage, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	StreamIn(ctx context.Context, opts ...grpc.CallOption) (VContainer_StreamInClient, error)
	StreamOut(ctx context.Context, in *StreamOutSpec, opts ...grpc.CallOption) (VContainer_StreamOutClient, error)
	// Remove a property with the specified name from a container.
	//
	// Errors:
	// * None.
	RemoveProperty(ctx context.Context, in *google_protobuf1.StringValue, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	CurrentMemoryLimit(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*MemoryLimits, error)
	CurrentCPULimit(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*CPULimits, error)
}

type vContainerClient struct {
	cc *grpc.ClientConn
}

func NewVContainerClient(cc *grpc.ClientConn) VContainerClient {
	return &vContainerClient{cc}
}

func (c *vContainerClient) Run(ctx context.Context, in *ProcessSpec, opts ...grpc.CallOption) (*RunResponse, error) {
	out := new(RunResponse)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/Run", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) Stop(ctx context.Context, in *StopMessage, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/Stop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) Metrics(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*Metrics, error) {
	out := new(Metrics)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/Metrics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) SetGraceTime(ctx context.Context, in *google_protobuf2.Duration, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/SetGraceTime", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) Properties(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*Properties, error) {
	out := new(Properties)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/Properties", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) Info(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*ContainerInfo, error) {
	out := new(ContainerInfo)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) NetIn(ctx context.Context, in *NetInRequest, opts ...grpc.CallOption) (*NetInResponse, error) {
	out := new(NetInResponse)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/NetIn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) NetOut(ctx context.Context, in *NetOutRuleRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/NetOut", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) BulkNetOut(ctx context.Context, in *BulkNetOutRuleRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/BulkNetOut", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) Property(ctx context.Context, in *google_protobuf1.StringValue, opts ...grpc.CallOption) (*google_protobuf1.StringValue, error) {
	out := new(google_protobuf1.StringValue)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/Property", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) SetProperty(ctx context.Context, in *KeyValueMessage, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/SetProperty", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) StreamIn(ctx context.Context, opts ...grpc.CallOption) (VContainer_StreamInClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VContainer_serviceDesc.Streams[0], c.cc, "/vcontainermodels.VContainer/StreamIn", opts...)
	if err != nil {
		return nil, err
	}
	x := &vContainerStreamInClient{stream}
	return x, nil
}

type VContainer_StreamInClient interface {
	Send(*StreamInSpec) error
	CloseAndRecv() (*StreamInResponse, error)
	grpc.ClientStream
}

type vContainerStreamInClient struct {
	grpc.ClientStream
}

func (x *vContainerStreamInClient) Send(m *StreamInSpec) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vContainerStreamInClient) CloseAndRecv() (*StreamInResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StreamInResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vContainerClient) StreamOut(ctx context.Context, in *StreamOutSpec, opts ...grpc.CallOption) (VContainer_StreamOutClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VContainer_serviceDesc.Streams[1], c.cc, "/vcontainermodels.VContainer/StreamOut", opts...)
	if err != nil {
		return nil, err
	}
	x := &vContainerStreamOutClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VContainer_StreamOutClient interface {
	Recv() (*StreamOutResponse, error)
	grpc.ClientStream
}

type vContainerStreamOutClient struct {
	grpc.ClientStream
}

func (x *vContainerStreamOutClient) Recv() (*StreamOutResponse, error) {
	m := new(StreamOutResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vContainerClient) RemoveProperty(ctx context.Context, in *google_protobuf1.StringValue, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/RemoveProperty", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) CurrentMemoryLimit(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*MemoryLimits, error) {
	out := new(MemoryLimits)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/CurrentMemoryLimit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vContainerClient) CurrentCPULimit(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (*CPULimits, error) {
	out := new(CPULimits)
	err := grpc.Invoke(ctx, "/vcontainermodels.VContainer/CurrentCPULimit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VContainer service

type VContainerServer interface {
	// rpc Handle(google.protobuf.Empty) returns(string) {}
	Run(context.Context, *ProcessSpec) (*RunResponse, error)
	Stop(context.Context, *StopMessage) (*google_protobuf3.Empty, error)
	Metrics(context.Context, *google_protobuf3.Empty) (*Metrics, error)
	// Sets the grace time.
	SetGraceTime(context.Context, *google_protobuf2.Duration) (*google_protobuf3.Empty, error)
	// Properties returns the current set of properties
	Properties(context.Context, *google_protobuf3.Empty) (*Properties, error)
	Info(context.Context, *google_protobuf3.Empty) (*ContainerInfo, error)
	NetIn(context.Context, *NetInRequest) (*NetInResponse, error)
	NetOut(context.Context, *NetOutRuleRequest) (*google_protobuf3.Empty, error)
	BulkNetOut(context.Context, *BulkNetOutRuleRequest) (*google_protobuf3.Empty, error)
	// Property returns the value of the property with the specified name.
	//
	// Errors:
	// * When the property does not exist on the container.
	Property(context.Context, *google_protobuf1.StringValue) (*google_protobuf1.StringValue, error)
	// Set a named property on a container to a specified value.
	//
	// Errors:
	// * None.
	SetProperty(context.Context, *KeyValueMessage) (*google_protobuf3.Empty, error)
	StreamIn(VContainer_StreamInServer) error
	StreamOut(*StreamOutSpec, VContainer_StreamOutServer) error
	// Remove a property with the specified name from a container.
	//
	// Errors:
	// * None.
	RemoveProperty(context.Context, *google_protobuf1.StringValue) (*google_protobuf3.Empty, error)
	CurrentMemoryLimit(context.Context, *google_protobuf3.Empty) (*MemoryLimits, error)
	CurrentCPULimit(context.Context, *google_protobuf3.Empty) (*CPULimits, error)
}

func RegisterVContainerServer(s *grpc.Server, srv VContainerServer) {
	s.RegisterService(&_VContainer_serviceDesc, srv)
}

func _VContainer_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/Run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).Run(ctx, req.(*ProcessSpec))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).Stop(ctx, req.(*StopMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_Metrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf3.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).Metrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/Metrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).Metrics(ctx, req.(*google_protobuf3.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_SetGraceTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf2.Duration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).SetGraceTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/SetGraceTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).SetGraceTime(ctx, req.(*google_protobuf2.Duration))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_Properties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf3.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).Properties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/Properties",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).Properties(ctx, req.(*google_protobuf3.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf3.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).Info(ctx, req.(*google_protobuf3.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_NetIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).NetIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/NetIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).NetIn(ctx, req.(*NetInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_NetOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetOutRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).NetOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/NetOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).NetOut(ctx, req.(*NetOutRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_BulkNetOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkNetOutRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).BulkNetOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/BulkNetOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).BulkNetOut(ctx, req.(*BulkNetOutRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_Property_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).Property(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/Property",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).Property(ctx, req.(*google_protobuf1.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_SetProperty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyValueMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).SetProperty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/SetProperty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).SetProperty(ctx, req.(*KeyValueMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_StreamIn_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VContainerServer).StreamIn(&vContainerStreamInServer{stream})
}

type VContainer_StreamInServer interface {
	SendAndClose(*StreamInResponse) error
	Recv() (*StreamInSpec, error)
	grpc.ServerStream
}

type vContainerStreamInServer struct {
	grpc.ServerStream
}

func (x *vContainerStreamInServer) SendAndClose(m *StreamInResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vContainerStreamInServer) Recv() (*StreamInSpec, error) {
	m := new(StreamInSpec)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _VContainer_StreamOut_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamOutSpec)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VContainerServer).StreamOut(m, &vContainerStreamOutServer{stream})
}

type VContainer_StreamOutServer interface {
	Send(*StreamOutResponse) error
	grpc.ServerStream
}

type vContainerStreamOutServer struct {
	grpc.ServerStream
}

func (x *vContainerStreamOutServer) Send(m *StreamOutResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _VContainer_RemoveProperty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).RemoveProperty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/RemoveProperty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).RemoveProperty(ctx, req.(*google_protobuf1.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_CurrentMemoryLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf3.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).CurrentMemoryLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/CurrentMemoryLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).CurrentMemoryLimit(ctx, req.(*google_protobuf3.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VContainer_CurrentCPULimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf3.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VContainerServer).CurrentCPULimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VContainer/CurrentCPULimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VContainerServer).CurrentCPULimit(ctx, req.(*google_protobuf3.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _VContainer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vcontainermodels.VContainer",
	HandlerType: (*VContainerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Run",
			Handler:    _VContainer_Run_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _VContainer_Stop_Handler,
		},
		{
			MethodName: "Metrics",
			Handler:    _VContainer_Metrics_Handler,
		},
		{
			MethodName: "SetGraceTime",
			Handler:    _VContainer_SetGraceTime_Handler,
		},
		{
			MethodName: "Properties",
			Handler:    _VContainer_Properties_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _VContainer_Info_Handler,
		},
		{
			MethodName: "NetIn",
			Handler:    _VContainer_NetIn_Handler,
		},
		{
			MethodName: "NetOut",
			Handler:    _VContainer_NetOut_Handler,
		},
		{
			MethodName: "BulkNetOut",
			Handler:    _VContainer_BulkNetOut_Handler,
		},
		{
			MethodName: "Property",
			Handler:    _VContainer_Property_Handler,
		},
		{
			MethodName: "SetProperty",
			Handler:    _VContainer_SetProperty_Handler,
		},
		{
			MethodName: "RemoveProperty",
			Handler:    _VContainer_RemoveProperty_Handler,
		},
		{
			MethodName: "CurrentMemoryLimit",
			Handler:    _VContainer_CurrentMemoryLimit_Handler,
		},
		{
			MethodName: "CurrentCPULimit",
			Handler:    _VContainer_CurrentCPULimit_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamIn",
			Handler:       _VContainer_StreamIn_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamOut",
			Handler:       _VContainer_StreamOut_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

// Client API for VProcess service

type VProcessClient interface {
	Signal(ctx context.Context, in *SignalRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
	Wait(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (VProcess_WaitClient, error)
	SetTTY(ctx context.Context, in *TTYSpec, opts ...grpc.CallOption) (*google_protobuf3.Empty, error)
}

type vProcessClient struct {
	cc *grpc.ClientConn
}

func NewVProcessClient(cc *grpc.ClientConn) VProcessClient {
	return &vProcessClient{cc}
}

func (c *vProcessClient) Signal(ctx context.Context, in *SignalRequest, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VProcess/Signal", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vProcessClient) Wait(ctx context.Context, in *google_protobuf3.Empty, opts ...grpc.CallOption) (VProcess_WaitClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VProcess_serviceDesc.Streams[0], c.cc, "/vcontainermodels.VProcess/Wait", opts...)
	if err != nil {
		return nil, err
	}
	x := &vProcessWaitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VProcess_WaitClient interface {
	Recv() (*WaitResponse, error)
	grpc.ClientStream
}

type vProcessWaitClient struct {
	grpc.ClientStream
}

func (x *vProcessWaitClient) Recv() (*WaitResponse, error) {
	m := new(WaitResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vProcessClient) SetTTY(ctx context.Context, in *TTYSpec, opts ...grpc.CallOption) (*google_protobuf3.Empty, error) {
	out := new(google_protobuf3.Empty)
	err := grpc.Invoke(ctx, "/vcontainermodels.VProcess/SetTTY", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VProcess service

type VProcessServer interface {
	Signal(context.Context, *SignalRequest) (*google_protobuf3.Empty, error)
	Wait(*google_protobuf3.Empty, VProcess_WaitServer) error
	SetTTY(context.Context, *TTYSpec) (*google_protobuf3.Empty, error)
}

func RegisterVProcessServer(s *grpc.Server, srv VProcessServer) {
	s.RegisterService(&_VProcess_serviceDesc, srv)
}

func _VProcess_Signal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VProcessServer).Signal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VProcess/Signal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VProcessServer).Signal(ctx, req.(*SignalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VProcess_Wait_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(google_protobuf3.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VProcessServer).Wait(m, &vProcessWaitServer{stream})
}

type VProcess_WaitServer interface {
	Send(*WaitResponse) error
	grpc.ServerStream
}

type vProcessWaitServer struct {
	grpc.ServerStream
}

func (x *vProcessWaitServer) Send(m *WaitResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _VProcess_SetTTY_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TTYSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VProcessServer).SetTTY(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vcontainermodels.VProcess/SetTTY",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VProcessServer).SetTTY(ctx, req.(*TTYSpec))
	}
	return interceptor(ctx, in, info, handler)
}

var _VProcess_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vcontainermodels.VProcess",
	HandlerType: (*VProcessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Signal",
			Handler:    _VProcess_Signal_Handler,
		},
		{
			MethodName: "SetTTY",
			Handler:    _VProcess_SetTTY_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Wait",
			Handler:       _VProcess_Wait_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

func (m *ContainersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainersResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Handle) > 0 {
		for _, s := range m.Handle {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *StopRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kill {
		dAtA[i] = 0x8
		i++
		if m.Kill {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StopResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Service(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Service(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintService(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ContainersResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Handle) > 0 {
		for _, s := range m.Handle {
			l = len(s)
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *StopRequest) Size() (n int) {
	var l int
	_ = l
	if m.Kill {
		n += 2
	}
	return n
}

func (m *StopResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovService(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozService(x uint64) (n int) {
	return sovService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ContainersResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainersResponse{`,
		`Handle:` + fmt.Sprintf("%v", this.Handle) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StopRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StopRequest{`,
		`Kill:` + fmt.Sprintf("%v", this.Kill) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StopResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StopResponse{`,
		`}`,
	}, "")
	return s
}
func valueToStringService(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ContainersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = append(m.Handle, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kill", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kill = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthService
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowService
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipService(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthService = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowService   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("service.proto", fileDescriptorService) }

var fileDescriptorService = []byte{
	// 770 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcd, 0x4e, 0xdb, 0x4c,
	0x14, 0xb5, 0x45, 0xbe, 0x10, 0x2e, 0x01, 0x3e, 0xcd, 0x02, 0x41, 0xa0, 0x06, 0x0c, 0x55, 0x59,
	0xa0, 0x50, 0xd1, 0x4d, 0x37, 0x6d, 0x29, 0x01, 0x01, 0xe5, 0x27, 0xc8, 0x0e, 0xa9, 0x90, 0xba,
	0x31, 0xce, 0x25, 0xb2, 0xb0, 0x3d, 0xee, 0x78, 0x4c, 0x95, 0x5d, 0x1f, 0xa1, 0x8f, 0xd1, 0x4d,
	0xdf, 0xa3, 0x4b, 0xd4, 0x45, 0xd5, 0x65, 0x49, 0x37, 0x5d, 0xf2, 0x08, 0x95, 0x27, 0xb6, 0xd3,
	0x12, 0xdb, 0x29, 0xdd, 0x79, 0xe6, 0xdc, 0x73, 0x74, 0xe7, 0xdc, 0x33, 0x63, 0x98, 0xf0, 0x91,
	0x5d, 0x59, 0x26, 0x56, 0x3d, 0x46, 0x39, 0x25, 0xff, 0x5f, 0x99, 0xd4, 0xe5, 0x86, 0xe5, 0x22,
	0x73, 0x68, 0x0b, 0x6d, 0xbf, 0xa2, 0xb4, 0x29, 0x6d, 0xdb, 0xb8, 0x2e, 0xf0, 0xf3, 0xe0, 0x62,
	0xbd, 0x15, 0x30, 0x83, 0x5b, 0xd4, 0xed, 0x31, 0x2a, 0x73, 0x77, 0x71, 0x74, 0x3c, 0xde, 0x89,
	0xc0, 0x01, 0xf2, 0x3b, 0x66, 0x78, 0x1e, 0x32, 0x3f, 0xc2, 0xcb, 0x26, 0x75, 0x9c, 0x44, 0xaa,
	0xdc, 0x36, 0x58, 0x0b, 0xe3, 0xd5, 0x54, 0xd2, 0x49, 0xb4, 0x31, 0xe1, 0x31, 0x6a, 0xa2, 0x1f,
	0x71, 0xd5, 0x35, 0x20, 0xb5, 0xb8, 0xc2, 0xd7, 0xd0, 0xf7, 0xa8, 0xeb, 0x23, 0x99, 0x86, 0xe2,
	0x9e, 0xe1, 0xb6, 0x6c, 0x9c, 0x91, 0x17, 0x47, 0x56, 0xc7, 0xb4, 0x68, 0xa5, 0x2e, 0xc1, 0xb8,
	0xce, 0xa9, 0xa7, 0xe1, 0xdb, 0x00, 0x7d, 0x4e, 0x08, 0x14, 0x0e, 0x2c, 0xdb, 0x9e, 0x91, 0x17,
	0xe5, 0xd5, 0x92, 0x26, 0xbe, 0xd5, 0x49, 0x28, 0xf7, 0x4a, 0x7a, 0x52, 0x1b, 0x5f, 0x0b, 0x30,
	0xda, 0xdc, 0x15, 0x2d, 0x91, 0xa7, 0x50, 0x38, 0xb1, 0xdc, 0x36, 0x99, 0xae, 0xf6, 0x4e, 0x54,
	0x8d, 0x4f, 0x54, 0xdd, 0x09, 0x8f, 0x5b, 0xc9, 0xd8, 0x57, 0x25, 0xb2, 0x09, 0xa5, 0x9a, 0xe1,
	0x19, 0xa6, 0xc5, 0x3b, 0x99, 0xec, 0x4a, 0xf5, 0xae, 0xed, 0xd5, 0x98, 0xa3, 0x4a, 0xa4, 0x06,
	0xc5, 0x1a, 0x43, 0x83, 0x23, 0x59, 0x48, 0xa9, 0x8b, 0xd7, 0xba, 0x87, 0x66, 0x4e, 0x1b, 0x2f,
	0x61, 0x74, 0x1b, 0x7d, 0xce, 0x68, 0x87, 0xcc, 0x0f, 0x14, 0xe9, 0x9c, 0x59, 0x6e, 0xbb, 0x69,
	0xd8, 0x01, 0xe6, 0x48, 0x68, 0x00, 0x7d, 0xc3, 0xc9, 0xfc, 0x60, 0x2f, 0x27, 0x8c, 0x7a, 0xc8,
	0xb8, 0x85, 0x7e, 0x65, 0x25, 0xa7, 0xd3, 0x64, 0x58, 0xaa, 0x44, 0x74, 0x28, 0x6d, 0x05, 0xf6,
	0xe5, 0xbe, 0x7b, 0x41, 0xc9, 0xd2, 0x20, 0x27, 0xc6, 0xa2, 0xb1, 0x55, 0xd4, 0xbc, 0x92, 0x44,
	0xf4, 0x0d, 0x8c, 0x87, 0xbb, 0x47, 0xc8, 0x99, 0x65, 0xfa, 0x64, 0x25, 0x9d, 0x14, 0xc1, 0xb1,
	0xf4, 0xc3, 0x21, 0x55, 0x89, 0xfa, 0x26, 0x14, 0x0f, 0x29, 0xbd, 0x0c, 0xbc, 0x7f, 0x35, 0x72,
	0xe3, 0xd3, 0x18, 0x40, 0x33, 0xb1, 0x83, 0xec, 0xc0, 0x88, 0x16, 0xb8, 0xe4, 0x41, 0xaa, 0xa1,
	0x61, 0xe0, 0xc5, 0x68, 0x53, 0x60, 0x2d, 0x70, 0x7f, 0xeb, 0xeb, 0x05, 0x14, 0xc2, 0xf8, 0xa6,
	0xe9, 0x84, 0xfb, 0x47, 0xe8, 0xfb, 0x46, 0x3b, 0x6f, 0xbe, 0xcf, 0x61, 0x34, 0xb6, 0x2c, 0x2b,
	0xa8, 0xb3, 0x83, 0xda, 0x11, 0x45, 0xe4, 0xb4, 0xac, 0x23, 0xdf, 0x65, 0x86, 0x89, 0x0d, 0xcb,
	0x41, 0x32, 0x3b, 0x20, 0xb2, 0x1d, 0x3d, 0x1d, 0x39, 0x4d, 0x6c, 0x03, 0xf4, 0x63, 0x94, 0xd9,
	0x47, 0x6e, 0xf8, 0x44, 0xda, 0x0b, 0x22, 0x52, 0x59, 0xfc, 0xbc, 0x8b, 0x14, 0x12, 0x55, 0x89,
	0xbc, 0x82, 0xff, 0x8e, 0x91, 0xef, 0xbb, 0x44, 0x19, 0xac, 0x15, 0x40, 0x1c, 0x9c, 0x85, 0x4c,
	0x3c, 0x19, 0xcd, 0x2e, 0x14, 0x8f, 0x91, 0xd7, 0x03, 0x4e, 0x96, 0x53, 0x8b, 0xeb, 0x01, 0xd7,
	0x02, 0x1b, 0x63, 0xc5, 0x6c, 0x77, 0xea, 0x00, 0x61, 0x28, 0x23, 0xb1, 0x47, 0xe9, 0x91, 0xbd,
	0x8f, 0xe0, 0x1e, 0x94, 0x22, 0xe3, 0x86, 0xbd, 0x0b, 0xb9, 0xa8, 0xf0, 0x6b, 0x5c, 0x47, 0x9e,
	0x88, 0xa5, 0x5c, 0xe6, 0x03, 0xec, 0x88, 0xe2, 0xe1, 0x49, 0xd4, 0xa0, 0xa4, 0x73, 0x86, 0x86,
	0x93, 0x6e, 0x7f, 0x8c, 0x89, 0x7b, 0xa1, 0x66, 0xe3, 0xfd, 0x09, 0xac, 0xca, 0xe4, 0x14, 0xc6,
	0x7a, 0xfb, 0xa1, 0x73, 0x0b, 0x59, 0xa4, 0x7a, 0xc0, 0x85, 0xea, 0x72, 0x4e, 0x41, 0x5f, 0xf6,
	0xb1, 0x4c, 0xf6, 0x60, 0x52, 0x43, 0x87, 0x5e, 0xe1, 0x5f, 0xda, 0x98, 0x7d, 0xe8, 0x63, 0x20,
	0xb5, 0x80, 0x31, 0x74, 0xf9, 0x11, 0x3a, 0x94, 0x75, 0x0e, 0x2d, 0xc7, 0xe2, 0x99, 0x09, 0x56,
	0xd2, 0x6e, 0x62, 0x42, 0xf3, 0xc5, 0x68, 0xa7, 0x22, 0xbd, 0xda, 0xc9, 0x69, 0xbe, 0xd8, 0x5c,
	0xca, 0x75, 0x88, 0x38, 0xbe, 0x2a, 0x6d, 0x7c, 0x91, 0xa1, 0xd4, 0x8c, 0xde, 0xa2, 0xf0, 0x6f,
	0xa4, 0x5b, 0x6d, 0xd7, 0xb0, 0x53, 0x4d, 0x14, 0xc8, 0xf0, 0xd8, 0x6d, 0x41, 0xe1, 0xb5, 0x71,
	0xbf, 0xd3, 0x85, 0xf5, 0x7f, 0x38, 0xff, 0x0c, 0x8a, 0x3a, 0xf2, 0x46, 0xe3, 0x8c, 0xa4, 0xbc,
	0x4a, 0x8d, 0xc6, 0x59, 0xfe, 0x0f, 0x71, 0x6b, 0xed, 0xfa, 0x46, 0x91, 0xbe, 0xdd, 0x28, 0xd2,
	0xed, 0x8d, 0x22, 0xbf, 0xef, 0x2a, 0xf2, 0xc7, 0xae, 0x22, 0x7f, 0xee, 0x2a, 0xf2, 0x75, 0x57,
	0x91, 0xbf, 0x77, 0x15, 0xf9, 0x67, 0x57, 0x91, 0x6e, 0xbb, 0x8a, 0xfc, 0xe1, 0x87, 0x22, 0x9d,
	0x17, 0x05, 0xff, 0xc9, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa6, 0xdc, 0x16, 0x03, 0x2f, 0x09,
	0x00, 0x00,
}
